# 第四期 Linux驱动开发
---
linux下的各种驱动开发不会再直接操作CPU的寄存器，而是满足linux框架，又linux内核来操作底层来实现。**所以Linux驱动重要的一点就是要熟悉框架**

驱动在linux下的体现也是以文件形式出现的，在/dev/xxx，利用打开、关闭、读写该文件来实现驱动的控制

设备树文件表述板子的设备信息，传递给linux内核方便底层调用

驱动开发分为三大类：**字符设备驱动** 如键盘和屏幕驱动、 **块设备**(U盘)、**网络设备驱动**(WIFI、网卡)。一个设备驱动不单单属于一大类的驱动，可能是多大类的复合

# 4.1 驱动开发流程和原理

以字符设备驱动为例，来熟悉驱动和linux框架流程

## 驱动原理
驱动是获取外设及其输入输出的信息来控制外设。外设的数据是提交给应用程序，由应用程序来处理数据。通常在开发过程中，还需要编写一个简单的测试应用程序、APP。即**linux驱动开发下，驱动和应用是分开的**。由此特性，linux的空间分为用户空间和内核空间，它们的调用关系如图所示。

![1](.\pictures\1.png)

相关连接：[linux内核空间、用户空间](https://blog.csdn.net/qq_28877125/article/details/108330634)

重要的是**linux操作系统内核和驱动程序运行在内核空间，应用程序运行在用户空间**

那么，应用程序如何和内核交互呢？主要有三种方案，`系统调用`

* 系统调用是最常见的交互方式，类似于调用API函数一样，“系统调用”的方法来实现从用户空间“陷入”到内核空间，这样才能实现对底层驱动的操作。如打开文件，linux内核提供了一个OPEN函数，来实现访问内核空间

![2](.\pictures\2.png)


## 开发流程

linux一切皆文件，所以编写驱动的时候会编写驱动对用的open、close等API函数，实现应用和内核的交互。

# 4.2 第一个linux驱动实验

linux一个应用程序的调用的流程如下

![3](.\pictures\3.png)

对应的驱动部分重点是编写驱动程序中的open()、close()等，不是应用层的open()、close()。驱动层的文件操作，**重点是实现/include/linux/fs.h中file_operations[]** 的要求

linux驱动程序可以编译到kernel里面，也就是zImage，也可以编译为模块。编译成模块，测试的时候只需要加载即可，模块的加载在后续会详细介绍

## 4.2.1 linux驱动框架第一步:驱动模块的加载和卸载

**驱动编写的时候的注意事项**

* 1 编译驱动的时候需要用到linux内核源码。因此要解压linux内核源码、编译linux内核源码得到zImage和dtb，需要使用编译后的zImage和dtb。

* 2 linux内核版本推荐使用第三期视频移植的版本，不推荐正点原子版本的linux内核，因为已经修改好了 

### 驱动模块加载
Linux驱动有两种运行方式，第一种就是将驱动编译进 Linux内核中，这样当 Linux内核启动的时候就会自动运行驱动程序。第二种就是将驱动编译成模块 (Linux下模块扩展名为 .ko)，在Linux内核启动以后使用“ insmod”命令加载驱动模块。

调试的时候选择第二种。linux内核提供给了两个函数以便模块的加载和卸载。
```
module_init(加载的函数);
module_exit(要注销的函数);
```
加载和注销的函数的返回值有严格的限定，但函数名没有，但通常以_init表示加载 _exit表示卸载。本实验的加载和卸载函数如下所示
```
/*
 * 要注册的驱动
*/
static int __init chrdevbase_init(void){
    int ret = 0;
    printk("chrdevbase_init\r\n");
    /*注册字符设备*/
    ret = register_chrdev(CHRDEVBASE_MAJOR, CHRDEVBASE_NAME,&chrdevbase_fops);
    
    if(ret < 0){//出错
        printk("chrdevbase init failed\r\n");
    }

    return 0;
}

static void __exit chrdevbase_exit(void){
    printk("exit chrdevbase\r\n");
    /*注销字符设备*/
    unregister_chrdev(CHRDEVBASE_MAJOR, CHRDEVBASE_NAME);  
}
```
具体看看`register_chrdev`和`unregister_chrdev`的函数原型
```
static inline int register_chrdev(unsigned int major, const char *name,
				  const struct file_operations *fops)
{
	return __register_chrdev(major, 0, 256, name, fops);
}

static inline void unregister_chrdev(unsigned int major, const char *name)
{
	__unregister_chrdev(major, 0, 256, name);
}
```
重点关注参数，不过分探究实现过程
`register_chrdev`中的参数

* major:主设备号

为了方便管理， Linux中每个设备都有一个设备号，设备号由主设备号和次设备号两部分组成，主设备号表示某一个具体的驱动，次设备号表示使用这个驱动的各个设备。 Linux提供了
一个名为 dev_t的数据类型表示设备号，这个数据类型起始就是一个整型32位，**其中高12位为主设备号， 低 20位为次设备号。因此 Linux系统中主设备号范围为 0~4095，所以选择主设备号的时候一定不要超过这个范围。**

linux也提供了相应宏定义方便快速设定设备的主从设备号在/include/linux/kdev_t.h下
```
#define MINORBITS	20
#define MINORMASK	((1U << MINORBITS) - 1)

#define MAJOR(dev)	((unsigned int) ((dev) >> MINORBITS)) //返回dev的主设备号
#define MINOR(dev)	((unsigned int) ((dev) & MINORMASK)) //返回dev的从设备号
#define MKDEV(ma,mi)	(((ma) << MINORBITS) | (mi)) //将ma,mi形成一个dev_t变量的设备号
```

*  name
驱动设备名称，用于在linux内核中挂在时使用

* fops
设备的操作函数集合，用于指向驱动能实现的操作内核的函数，在下一节会重点去完善
这个时候，就完成了驱动框架的第一部分，对驱动设备的注册和卸载。在注册函数中有一行`ret = register_chrdev(CHRDEVBASE_MAJOR, CHRDEVBASE_NAME,&chrdevbase_fops);`这一部分就是要具体完善的设备驱动执行的操作，在下一节会讲解

### printk
printk就是Linux内核的字符打印函数。需要说明的是printk有时候可能会打乱输出信息，因为如果应用函数有打印任务，如printf()，调用内核时也打印了printk()可能导致输出信息紊乱，请注意识别

## 4.2.2 linux驱动框架第二步：实现设备的具体操作函数
该节的核心就是完善设备注册和卸载函数中的`register_chrdev`中提到的`file_operations *fops`变量，及操作内核函数集合

先来看看它的原型
```
struct file_operations {
	struct module *owner;
	loff_t (*llseek) (struct file *, loff_t, int);
	ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
	ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
	ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);
	ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);
	int (*iterate) (struct file *, struct dir_context *);
	unsigned int (*poll) (struct file *, struct poll_table_struct *);
	long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
	long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
	int (*mmap) (struct file *, struct vm_area_struct *);
	int (*mremap)(struct file *, struct vm_area_struct *);
	int (*open) (struct inode *, struct file *);
	int (*flush) (struct file *, fl_owner_t id);
	int (*release) (struct inode *, struct file *);
	int (*fsync) (struct file *, loff_t, loff_t, int datasync);
	int (*aio_fsync) (struct kiocb *, int datasync);
	int (*fasync) (int, struct file *, int);
	int (*lock) (struct file *, int, struct file_lock *);
	ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);
	unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
	int (*check_flags)(int);
	int (*flock) (struct file *, int, struct file_lock *);
	ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
	ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
	int (*setlease)(struct file *, long, struct file_lock **, void **);
	long (*fallocate)(struct file *file, int mode, loff_t offset,
			  loff_t len);
	void (*show_fdinfo)(struct seq_file *m, struct file *f);
#ifndef CONFIG_MMU
	unsigned (*mmap_capabilities)(struct file *);
#endif
};
```
好在，我们并不需要实现全部结构体中都是函数，而是选中实现部分即可。

基本的设备驱动函数需要实现设备打开、关闭和读写，因此实现的操作函数如下
```
static struct file_operations chrdevbase_fops = {
    .owner = THIS_MODULE,
    .open = chrdevbase_open,
    .release = chrdevbase_release,
    .read = chrdevbase_read,
    .write = chrdevbase_write, 
};
```
注意`.owner = THIS_MODULE,`是每个设备驱动必备的，它用于指定是哪个设备的操作函数集合.接下来就是实现`.open`等所指向的具体操作函数

### 设备打开
`file_operations`规定了`int (*open) (struct inode *, struct file *)`，所以打开函数的原型必须这样，参考linux常见的文件打开函数，该试验的设备打开驱动函数如下
```
static int chrdevbase_open(struct inode *inodes, struct file *file){
    printk("chrdevbase_open\r\n");
    /*想实现的内容*/
    return 0;
}
```
staitc 是标定该函数仅这个文件内可见，避免编译链接的时候出现相同函数而出错

### 设备关闭
同理设备打开
```
static int chrdevbase_release(struct inode *inodes, struct file *filp){
    //printk("chrdevbase_release\r\n");
    /*想实现的内容*/
    return 0;
}
```

### 设备读
值得注意的是**设备读写操作是针对应用程序对内核的**，及驱动程序端是它们的媒介。驱动端的读指的是**应用程序从内核中读取数据**。函数具体实现如下
```
/*应用程序读取驱动端数据*/
static ssize_t chrdevbase_read(struct file *filp, char __user *buf, size_t count, loff_t *ppos){
    int ret = 0;
    //先拷贝数据，不要直接发送原始数据
    memcpy(readbuf,kerneldata,sizeof kerneldata);
    //向应用程序发送数据
    ret = copy_to_user(buf,readbuf,count);
    if(ret != 0){
        printk("copy failed!\r\n");
    }
    return 0;
}
```
应当参看上述实现方式，对内核的读写应当先拷贝数据，尽量不要触动原始数据

### 设备写
同理，驱动端的设备写是**应用程序向内核写数据**
```
/*应用程序向驱动端写数据*/
static ssize_t chrdevbase_write(struct file *filp, const char __user *buf, size_t count, loff_t *ppos){
    int ret = 0;
    ret = copy_from_user(writebuf , buf , count);
    if(ret != 0 ){
        printk("write to kernel failed\r\n");
    }
    else{
        //printk("write to kernel %s\r\n" , writebuf);
    }
    return 0;
}
```
至此，实现驱动端具体操作函数就全部写完了，接下来进行一些收尾工作即可。

### 4.2.3 linux驱动框架第三步：添加 LICENSE和作者信息
最后我们需要在驱动中加入 LICENSE信息和作者信息，其中 LICENSE是必须添加的，否则的话编译的时候会报错，作者信息可以添加也可以不添加。函数如下
```
MODULE_LICENSE();//添加LICENSE
MODULE_AUTHOR() //添加模块作者信息
```

LICENSE不能随意添加，要符合linux的规范
```
MODULE_LICENSE("GPL");          // "GPL" 是指明了 这是GNU General Public License的任意版本
                                // “GPL v2” 是指明 这仅声明为GPL的第二版本
                                // "GPL and addtional"
                                // "Dual BSD/GPL"
                                // "Dual MPL/GPL"
                                // "Proprietary"  私有的
                                // 除非你的模块显式地声明一个开源版本，否则内核会默认你这是一个私有的模块(Proprietary)。
 
MODULE_AUTHOR                   // 声明作者
MODULE_DESCRIPTION              // 对这个模块作一个简单的描述，这个描述是"human-readable"的
MODULE_VERSION                  // 这个模块的版本
MODULE_ALIAS                    // 这个模块的别名
MODULE_DEVICE_TABLE             // 告诉用户空间这个模块支持什么样的设备
```

进过上述三步，驱动端的框架就算全部完成了。接下来写一个简易的应用程序来测试一下

## 4.3 APP测试
这里的APP起始就是一个应用程序。编写用来测试刚写的驱动端是否正确。具体实现如下
```
/*
 *驱动测试APP
*/
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

/*
* argc:应用程序参数个数
* argv[]:传递给应用程序的参数内容
    -> 1    <filename> 驱动在Linux下的文件路径
    -> 2    <rwcmd>    1:表示读驱动 2：表示写驱动
*/

int main(int argc , char *argv[]){

    int ret = 0;
    int fd = 0; //文件描述符
    char *filename;
    char readbuf[100] , writebuf[100] = {"hello Linux!"};

    if(argc != 3){
        printf("参数传递错误\r\n , 主程序结束返回-1\r\n");
        return -1;
    }

    filename = argv[1];
    /*打开文件*/
    fd = open(filename, O_RDWR);
    if(fd < 0){
        printf("Cant open file %s\r\n" , filename);
        return -1;
    }

    if(*argv[2] == '1'){ //应用程序读数据
        /*读写文件*/
        ret = read(fd , readbuf , 50);
        if(ret < 0){//读失败
            printf("read %s failed \r\n" , filename);
            //return -1;
        }
        else{ //读成功
            printf("APP read data from kernel: %s\r\n" ,readbuf);
        }
    }

     if(*argv[2] == '2'){ //应用程序写数据
        /*读写文件*/
        ret = write(fd,writebuf,50);
        if(ret < 0){//写失败
            printf("write %s failed \r\n" , filename);
            //return -1;
        }
        else{ //写成功
            printf("write to kernel data : %s\r\n" , writebuf);
        }
    }

    /*关闭文件*/
    ret = close(fd);
    if(ret < 0){//关闭文件失败
        printf("close %s failed \r\n" , filename);
        //return -1;
    }
    else{ //关闭文件成功

    }

    return 0;
}
```
具体讲解一下参数及其含义。

同windos端的应用程序一样，需要一个main函数，并指定传入的参数，以字符串的形式。

### open函数
这里就对应上了驱动端写的`.open`，但应用程序的open函数原型如下
```
int open(const char *pathname, int flags)
```
* pathname 设备名
这个通过主函数参数进行传递，主函数调用时会指定驱动设备名

* flag 文件模式

O_RDONLY 只读模式

O_WRONLY 只写模式

O_RDWR 读写模式

在open后会返回一个int类型的文件描述，以指定打开了哪个文件

### close
对应驱动端操作函数集合的`.relsease`。函数形式如下
```
int close(int fd);
```
* fd:要关闭的文件的文件描述

### read
对应驱动端函数集合的`.read`。函数形式如下
```
ssize_t read(int fd, void *buf, size_t count)
```
* fd：要读取的文件描述符，读取文件之前要先用 open函数打开文件， open函数打开文件成功以后会得到文件描述符。

* buf 数据读取到此buf中。

* count 要读取的数据长度，也就是字节数。
返回值： 读取成功的话返回读取到的字节数；如果返回 0表示读取到了文件末尾；如果返回负值，表示读取失败。

### write
对应驱动端函数集合的`.write`。函数形式如下
```
ssize_t write(int fd, const void *buf, size_t count);
```
* fd：要进行写操作的文件描述符，写文件之前要先用 open函数打开文件， open函数打开文件成功以后会得到文件描述符。

* buf 要写入的数据。

* count 要写入的数据长度，也就是字节数。

* 返回值： 写入成功的话返回写入的字节数；如果返回 0表示没有写入任何数据；如果返回负值，表示写入失败。


至此，一个建议的测试应用程序边写完了。
在编译好，在linux中输入`./chrdevbaseApp /dev/chrdevbase 1`则参数会传递给主函数,`/dev/chrdevbase`会传递给fd，而1则表示读，及读一个驱动设备`/dev/chrdevbase`的值。

## 4.4 编译测试
注意：**根文件系统采用nfs挂载方式**.要事先确保根文件系统能成功挂载

编写一个建议的makefile文件实现快速编译和执行
```
export ARCH=arm
export CROSS_COMPILE=arm-linux-gnueabihf-

KERNELDIR := /home/constant_z/linux/IMX6ULL/linux/alientek_linux

CURRENT_PATH := $(shell pwd)

obj-m := chrdevbase.o

build: kernel_modules
	@echo "copy to rootfs"
	sudo cp chrdevbase.ko /home/constant_z/linux/nfs/rootfs/lib/modules/4.1.15/ -f

kernel_modules:
	$(MAKE) -C $(KERNELDIR) M=$(CURRENT_PATH) modules

buildApp: makeApp
	@echo "copy to rootfs"
	sudo cp chardevApp /home/constant_z/linux/nfs/rootfs/lib/modules/4.1.15/ -f

makeApp:
	arm-linux-gnueabihf-gcc chardevApp.c -o chardevApp

clean:
	$(MAKE) -C $(KERNELDIR) M=$(CURRENT_PATH) clean
```
### 编译模块
**内核编译报错：cc1: error: code model kernel does not support PIC mode 主要是因为内核的Makefile没有指定ARCH 和 CROSS_COMPLILE，直接在驱动的Makefile中expoer ARCH和 CROSS_COMLIE即可**

[解决cc1: error: code model kernel does not support PIC mode](https://blog.csdn.net/weixin_45010898/article/details/125763653)

### 驱动移植
首先，加载驱动，使用`insmod`或者`modprobe`加载命令都是默认在/lib/linux内核版本号/下寻找对应驱动。所以先确保对应文件夹下有.ko后缀的驱动文件

如图所示
![9](.\pictures\9.png)

### 驱动添加
接下来就可以输入命令
```
insmod xxx.ko 或者
modprobe xxx.ko
```
来向linux进行驱动添加
如果出现
```
modprobe: can't open 'modules.dep': No such file or directory
```
请使用命令 'depmod'，来手动生成一下。**注意：这里需要根文件系统支持这个命令，不支持请百度BusyBos编译添加depmod**

添加后，输入`lsmod`和`cat /proc/devices`来查看驱动是否成功添加

![6](.\pictures\6.png)

### 节点挂载
此时驱动已经成功添加，但没有实际挂载到linux中，因此应用程序无法调用。我们需要手动挂载一个节点使得应用程序能调用该驱动.

输入命令：
```
mknod /dev/驱动名称 c 主设备号 从设备号
```
本节驱动应该挂载的就是
`mknod /dev/led c 200 0`
此时，在`cd /dev/`就可以看见具体的节点了

![7](.\pictures\7.png)

### 运行测试
万事俱备，运行测试一下即可。输入命令
```
./chardevApp /dev/chrdevbase 0
```
![10](.\pictures\10.png)

### 驱动卸载
使用命令 `rmmod mokuaiming.ko`即可。再使用`lsmod`查看是否真的注销


# 5 完善第一个驱动试验
前面2个试验存在两点问题(1)手动分配设备号，浪费大量设备资源(2)需要手动挂载设备节点。本节针对这两点进行优化

## 自动申请和释放设备号

`alloc_chrdev_region`，原型如下
```
int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count,
			const char *name)
{
	struct char_device_struct *cd;
	cd = __register_chrdev_region(0, baseminor, count, name);
	if (IS_ERR(cd))
		return PTR_ERR(cd);
	*dev = MKDEV(cd->major, cd->baseminor);
	return 0;
}
```
参数说明

* dev_t *dev:最终申请到的设备号

* baseminor:手动添加次设备号

* count:设备数量

* name:设备名

此外，如果向指定一个设备的设备号(还没被使用)，可以通过`register_chrdev_region`实现，函数原型如
```
int register_chrdev_region(dev_t from, unsigned count, const char *name)
{
	struct char_device_struct *cd;
	dev_t to = from + count;
	dev_t n, next;

	for (n = from; n < to; n = next) {
		next = MKDEV(MAJOR(n)+1, 0);
		if (next > to)
			next = to;
		cd = __register_chrdev_region(MAJOR(n), MINOR(n),
			       next - n, name);
		if (IS_ERR(cd))
			goto fail;
	}
	return 0;
fail:
	to = n;
	for (n = from; n < to; n = next) {
		next = MKDEV(MAJOR(n)+1, 0);
		kfree(__unregister_chrdev_region(MAJOR(n), MINOR(n), next - n));
	}
	return PTR_ERR(cd);
}
```
参数说明：

* from: dev_t类型的完整设备号。利用`MKDEV`提供

* count:设备个数

* name :设备名字

**实际中，需要考虑完善，即给出给定设备号和没有给定设备号的情况，所以要使用上述2中设备号申请函数**


释放设备号`unregister_chrdev_region`，函数原型如下
```
void unregister_chrdev_region(dev_t from, unsigned count)
{
	dev_t to = from + count;
	dev_t n, next;

	for (n = from; n < to; n = next) {
		next = MKDEV(MAJOR(n)+1, 0);
		if (next > to)
			next = to;
		kfree(__unregister_chrdev_region(MAJOR(n), MINOR(n), next - n));
	}
}
```
参数说明：同`alloc_chrdev_region`一致

## 自动创建设备节点
在之前的设备驱动过程中，我们需要手动mknod来手动创建，现在改善如何自动创建设备节点.下面的udev程序就是实现该问题的

udev是一个用户程序，在 Linux下通过 udev来实现设备文件的创建与删除， udev可以检测系统中硬件设备状态，可以根据系统中硬件设备状态来创建或者删除设备文件。测系统中硬件设备状态，可以根据系统中硬件设备状态来创建或者删除设备文件。比如使用
modprobe命令成功加载驱动模块以后就自动在 /dev目录下创建对应的设备节点文件 ,使用rmmod命令卸载驱动模块以后就 删除掉 /dev目录下的设备节点文件。

mdev是udev的简化版本，是busybox在构建根文件时的建议版本


## 自动创建设备节点
在之前的设备驱动过程中，我们需要手动mknod来手动创建，现在改善如何自动创建设备节点.下面的udev程序就是实现该问题的

udev是一个用户程序，在 Linux下通过 udev来实现设备文件的创建与删除， udev可以检测系统中硬件设备状态，可以根据系统中硬件设备状态来创建或者删除设备文件。测系统中硬件设备状态，可以根据系统中硬件设备状态来创建或者删除设备文件。比如使用
modprobe命令成功加载驱动模块以后就自动在 /dev目录下创建对应的设备节点文件 ,使用rmmod命令卸载驱动模块以后就 删除掉 /dev目录下的设备节点文件。

mdev是udev的简化版本，是busybox在构建根文件时的建议版本

### 创建/摧毁类
```
/* This is a #define to keep the compiler from merging different
 * instances of the __key variable */
#define class_create(owner, name)		\
({						\
	static struct lock_class_key __key;	\
	__class_create(owner, name, &__key);	\
})
```
参数说明

### 创建/注销节点
```
struct device *device_create(struct class *class, struct device *parent,
			     dev_t devt, void *drvdata, const char *fmt, ...)
{
	va_list vargs;
	struct device *dev;

	va_start(vargs, fmt);
	dev = device_create_vargs(class, parent, devt, drvdata, fmt, vargs);
	va_end(vargs);
	return dev;
}
```
摧毁设备
```
void device_destroy(struct class *class, dev_t devt)
{
	struct device *dev;

	dev = class_find_device(class, NULL, &devt, __match_devt);
	if (dev) {
		put_device(dev);
		device_unregister(dev);
	}
}
```

## 程序编写
代码如下：
```
/*
 * 6 GPIO系统驱动试验
 * 驱动端程序
*/

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/fs.h>
#include <linux/uaccess.h> //调用copy_to_user要用到
#include <linux/io.h>
#include <linux/cdev.h>
#include <linux/device.h> //调用设备驱动用到
#include <linux/of.h> //调用of函数会用到
#include <linux/slab.h> //调用kmalloc kfree要用到
#include <linux/of_device.h>
#include <linux/of_address.h> //调用of_iomap时使用
#include <linux/of_gpio.h>  //of_get_named_gpio使用

#define GPIOLED_CNT 1
#define GPIOLED_NAME "gpioled"

#define LEDON  1
#define LEDOFF 0

/*gpioled设备结构体*/
struct gpioled_dev
{
    dev_t devid;
    int major;
    int minor;
    struct cdev mycdev;
    struct class *myclass;
    struct device *mydevice;
    struct device_node *nd;
    int led_gpio; //led 的 io编号

}gpioled;


/*实现具体驱动操作函数*/
static int led_open(struct inode *inode , struct file *filp){
    filp->private_data = &gpioled;//设置为私有数据
    return 0;
}

static int led_release(struct inode *inode , struct file *filp){
    struct gpioled *dev = (struct gpioled*)filp->private_data;
    return 0;
}

/*led打开或者关闭*/
void led_switch(unsigned char flag){
    if(flag == LEDON){
        gpio_set_value(gpioled.led_gpio , 0); //开启led
    }
    else{
        gpio_set_value(gpioled.led_gpio , 1); //关闭led
    }
}

static ssize_t led_write(struct file *filp, const char __user *buf, size_t count, loff_t *ppos){

    int ret;
    char databuf[1];
    struct gpioled *dev = (struct gpioled*)filp->private_data;
    ret = copy_from_user(databuf , buf , count);
    if(ret < 0){
        printk("invaild value\r\n");
        return -EINVAL;
    }
   if(databuf[0] == LEDON){
        gpio_set_value(gpioled.led_gpio , 0); //开启led
    }
    else if(databuf[0]  == LEDOFF){
        gpio_set_value(gpioled.led_gpio , 1); //关闭led
    }

    return 0;
}

static ssize_t led_read(struct file *file, char __user *buf, size_t size, loff_t *ppos){
    return 0;
}

static const struct file_operations led_fops = {
	.owner	= THIS_MODULE,
	.open	= led_open,
	.write	= led_write,
	.read	= led_read,
    .release = led_release,
};

static int __init led_init(void){
    int ret;
    printk("start to init gpioled\r\n");
    //注册字符设备驱动
    gpioled.major = 0;
    if(gpioled.major){
        gpioled.devid = MKDEV(gpioled.major , 0);
        register_chrdev_region(gpioled.devid , GPIOLED_CNT , GPIOLED_NAME);
    }
    else{ /*自动分配设备号*/
        alloc_chrdev_region(&gpioled.devid , 0 ,GPIOLED_CNT ,  GPIOLED_NAME);
    }
    gpioled.major = MAJOR(gpioled.devid);
    gpioled.minor = MINOR(gpioled.devid);
    printk("gpioled major = %d minor = %d\r\n",gpioled.major , gpioled.minor);

    //初始化字符cdev
    gpioled.mycdev.owner =  THIS_MODULE;
    cdev_init(&gpioled.mycdev , &led_fops);
    ret = cdev_add(&gpioled.mycdev , gpioled.devid , GPIOLED_CNT);
    if(ret < 0){
        printk("fail to access cdev\r\n");
    }

    //创建类
    gpioled.myclass = class_create(THIS_MODULE, GPIOLED_NAME);
    if(IS_ERR(gpioled.myclass)){
        printk("fail to create class\r\n");
        return PTR_ERR(gpioled.myclass);
    }

    //创建设备
    gpioled.mydevice = device_create(gpioled.myclass, NULL, gpioled.devid, NULL,GPIOLED_NAME);
    if(IS_ERR(gpioled.mydevice )){
        printk("fail to create device\r\n");
        return PTR_ERR(gpioled.mydevice );
    }

    //gpio相关操作
    //获取设备节点
    gpioled.nd = of_find_node_by_path("/gpioled");
    if(gpioled.nd == NULL){
        printk("fail to access device node\r\n");
        ret = -EINVAL;
        goto fail_fdnd;
    }
    //获取LED所对应的gpio
    gpioled.led_gpio = of_get_named_gpio(gpioled.nd , "led-gpios" , 0);
    if(gpioled.led_gpio < 0){
        printk("fail to access property name\r\n");
        ret = -EINVAL;
        goto  fail_fnnm;
    }
    printk("led gpio num = %d\r\n",gpioled.led_gpio);
    //申请GPIO
    ret = gpio_request(gpioled.led_gpio , "gpioled.led_gpio");
    if(ret){
        printk("fail to request gpio num\r\n");
        ret = -EINVAL;
        goto fail_getnm;
    }
    //使用IO
    ret = gpio_direction_output(gpioled.led_gpio , 1);//默认高电平 不点亮
    if(ret){
        printk("fail to set gpio output\r\n");
        ret = -EINVAL;
        goto fail_stout;
    }

    gpio_set_value(gpioled.led_gpio , 0); //开启led

    return 0;

fail_stout:
    gpio_free(gpioled.led_gpio);
fail_getnm:
fail_fnnm:
fail_fdnd:
    return ret;
}

static void __exit led_exit(void){
    //关闭LED
    gpio_set_value(gpioled.led_gpio , 1); //关闭LED
    //摧毁GPIO
    gpio_free(gpioled.led_gpio);
    //摧毁cdev
    cdev_del(&gpioled.mycdev);
    //注销字符设备
    unregister_chrdev_region(gpioled.devid , GPIOLED_CNT);
    //摧毁设备
    device_destroy(gpioled.myclass , gpioled.devid);
    //摧毁类
    class_destroy(gpioled.myclass);
}


module_init(led_init);
module_exit(led_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("constan_z");
```

如果出现
![8](.\pictures\8.png)
这表明**编译模块用到的内核和实际单片机运行的linux内核不一致**。那就需要修改单片机端的Linux内核，使其指向Makefile中`KERNELDIR`下的内核，重新编译下载到单片机即可

## 文件私有数据
为什么有私有数据?

因为我们在一个驱动里面可以支持多个设备，或者多个设备共用一个驱动，如果不进行私有数据的管理，那么很容易就会导致我们在驱动里面读取数据的时候出现错误，而设置私有数据就是为了避免这种情况。

私有数据指的是多个设备不会相互干扰的意思。

在驱动端的open函数中需要设置`filp->private_data = 设备结构体变量 变量名`。在read，write函数访问设备时候直接读取这个私有数据.如`设备结构体变量 变量名 = filp->private_data`



# 6 linux设备树
设备树(Device Tree)，将这个词分开就是“设备”和“树”，描述设备树的文件叫做 DTS(Device Tree Source)，这个 DTS 文件采用树形结构描述板级设备，也就是开发板上的设备信息，比如CPU 数量、 内存基地址、IIC 接口上接了哪些设备、SPI 接口上接了哪些设备等等。设备树的提出简化了linux内核中冗余的分散在各处的板级文件信息(以前用的.c文件去描述板级文件)，规范了Linux驱动的编写。

设备树文件从linux内核中分离出来，在arch/arm/boot/dts下编写成.dts的板级信息文件，编译后根据cpu架构的不同，编译形成.dtb文件加入linux内核.

![11](.\pictures\11.png)

树的主干就是系统总线，IIC 控制器、GPIO 控制器、SPI 控制器等都是接到系统主线上的分支。IIC 控制器有分为 IIC1 和 IIC2 两种，其中 IIC1 上接了 FT5206 和 AT24C02这两个 IIC 设备，IIC2 上只接了 MPU6050 这个设备。DTS 文件的主要功能就是按照图所示的结构来描述板子上的设备信息。DTS 文件描述设备信息是有相应的语法规则要求的，下面介绍设备树的语法规则。

## dts dtb和dtc的关系

.dts就是设备树源码文件，dtb就是根据.dts来编译后能linux内核识别的文件。dtc是用来帮助dts编译成dtb文件的。DTC工具源码在/scripts/dtc目录下

通过`make dtbs`编译所有的linux源码下的dts文件或者直接编译全部内核即可。

通过`make xxx.dts`即可编译指定的dtb，但前提是在/arch/arm/boot/dts的Makefile中有这样一个dbs添加到对应的架构下
```
dtb-$(CONFIG_SOC_IMX6ULL) += \
	imx6ull-14x14-ddr3-arm2.dtb \
	...
	imx6ull-alientek-emmc.dtb \ ->添加的
	imx6ull-14x14-evk-btwifi.dtb \
	...
```
如果编译出现
```
64-bit kernel (64BIT) [Y/n/?] (NEW)
```
这就是顶层Makefile没有指定好ARCH 和 CROSS_COMPILE。指定好即可

## DTS语法

DTS语法是一种ASCII文本文件，阅读和书写都十分方便。参看资料《Devicetree SpecificationV0.2.pdf》和 《Power_ePAPR_APPROVED_v1.12.pdf》

### .dts头文件
设备树支持头文件系统，包括.h头文件或者`.dtsi`头文件

```
/dts-v1/;
/*imx6ull-alientek-emmc.dts*/文件
#include <dt-bindings/input/input.h>
#include "imx6ull.dtsi"

/{
	model = "Freescale i.MX6 ULL 14x14 EVK Board";
	compatible = "fsl,imx6ull-14x14-evk", "fsl,imx6ull";

	...
	...
}
```
首行的`/dts-v1/;`是DTS文件的标准规范，规定每个.dts必须说明

通常引用的`.dtsi`应该是一个CPU通用的一些设备描述，比如CPU架构、主频和外设串口寄存器等等.

### 设备节点
设备树是采用树形结构来描述板子上的设备信息的文件，每个设备都是一个节点，叫做设备节点，每个节点都通过一些属性信息来描述节点信息，属性就是键—值对

看一个具体的设备节点
```
/*imx6ull.dtsi*/
/ {

	cpus {
		#address-cells = <1>;
		#size-cells = <0>;

		cpu0: cpu@0 {
			compatible = "arm,cortex-a7";
			device_type = "cpu";
			reg = <0>;
			clock-latency = <61036>; /* two CLK32 periods */
			operating-points = <
				/* kHz	uV */
				996000	1275000
				792000	1225000
				696000  1225000
				528000	1175000
				396000	1025000
				198000	950000
			>;
			fsl,soc-operating-points = <
				/* KHz	uV */
				996000	1175000
				792000	1175000
				528000	1175000
				396000	1175000
				198000	1175000
			>;
			fsl,low-power-run;
			clocks = <&clks IMX6UL_CLK_ARM>,
				 <&clks IMX6UL_CLK_PLL2_BUS>,
				 <&clks IMX6UL_CLK_PLL2_PFD2>,
				 <&clks IMX6UL_CA7_SECONDARY_SEL>,
				 <&clks IMX6UL_CLK_STEP>,
				 <&clks IMX6UL_CLK_PLL1_SW>,
				 <&clks IMX6UL_CLK_PLL1_SYS>,
				 <&clks IMX6UL_PLL1_BYPASS>,
				 <&clks IMX6UL_CLK_PLL1>,
				 <&clks IMX6UL_PLL1_BYPASS_SRC>,
				 <&clks IMX6UL_CLK_OSC>;
			clock-names = "arm", "pll2_bus",  "pll2_pfd2_396m", "secondary_sel", "step",
				      "pll1_sw", "pll1_sys", "pll1_bypass", "pll1", "pll1_bypass_src", "osc";
		};
	};

	intc: interrupt-controller@00a01000 {
		compatible = "arm,cortex-a7-gic";
		#interrupt-cells = <3>;
		interrupt-controller;
		reg = <0x00a01000 0x1000>,
		      <0x00a02000 0x100>;
	};

	clocks{
		...
	}
	...
	soc{
		...
	}
	...

}
```

根节点就是 `/`，其子节点如`cpus clocks soc`等就是子节点,`cpus`子节点中又描述了`cpu0:cpu@0`这样一个子节点，当然，只要愿意，子节点仍可以嵌套节点


下面是`imx6ull.dts`的设备树节点


设备树中的节点命名格式是
```
node-name@unit-address
```
node-name是一个字符串形式的节点名字，**约定只用小写字母和数字**。

```
i2c4: i2c@021f8000 {
				...
			};
```
但，`i2c4: i2c@021f8000`不符合节点命名格式。“：”前面的是节点标签(label)，“：”后面的才是节点名字。完整的格式如下
```
i2c4:i2c-@021f80000
```
表示i2c4节点下没有名字，其地址是0x021f8000,可以查看数据手册验证是否正确.当然这个节点地址可能是绝对地址，也有可能是相对地址等。

为什么要添加标签呢？引入 label 的目的就是为了方便访问节点，可以直接通过&label 来访问这个节点，比如通过&cpu0 就可以访问“cpu@0”这个节点，而不需要输入完整的节点名字。

那为什么要使用访问节点呢？`&cpu0`这样类似节点，就是追加（也叫访问）节点，用来追加在`.dtsi`中节点`cpu0`没有描述完的一些属性内容，这样做是为了针对imx6ull开发板追加的cpu的属性。
```
/*imx6ull.dts*/
&cpu0 {
	arm-supply = <&reg_arm>;
	soc-supply = <&reg_soc>;
	dc-supply = <&reg_gpio_dvfs>;
};
```
节点的名字和地址不是不要选项，但一定要有节点

### 特殊节点
在`imx6ull.dts`和`.disi`的根节点前面有两个特殊节点`chosen`和`aliases`
```
aliases {
		can0 = &flexcan1;
		can1 = &flexcan2;
		ethernet0 = &fec1;
		ethernet1 = &fec2;
		gpio0 = &gpio1;
		gpio1 = &gpio2;
		gpio2 = &gpio3;
		gpio3 = &gpio4;
		gpio4 = &gpio5;
		i2c0 = &i2c1;
		i2c1 = &i2c2;
		i2c2 = &i2c3;
		i2c3 = &i2c4;
		mmc0 = &usdhc1;
		mmc1 = &usdhc2;
		serial0 = &uart1;
		serial1 = &uart2;
		serial2 = &uart3;
		serial3 = &uart4;
		serial4 = &uart5;
		serial5 = &uart6;
		serial6 = &uart7;
		serial7 = &uart8;
		spi0 = &ecspi1;
		spi1 = &ecspi2;
		spi2 = &ecspi3;
		spi3 = &ecspi4;
		usbphy0 = &usbphy1;
		usbphy1 = &usbphy2;
	};
```
单词 aliases 的意思是“别名”，因此 aliases 节点的主要功能就是定义别名，定义别名的目
的就是为了方便访问节点。不过我们一般会在节点命名的时候会加上 label，然后通过&label
来访问节点，这样也很方便，而且设备树里面大量的使用&label 的形式来访问节点。注意的是**等号左侧是别名，右侧是实际的驱动**

它不失为一种访问节点的方式。

`chosen节点`
```
chosen {
		stdout-path = &uart1;
	};
```
chosen 并不是一个真实的设备，chosen 节点主要是为了 uboot 向 Linux 内核传递数据，重点是传递bootargs参数给内核。bootargs中来传递chonsen节点的内容。chonsen节点十分重要

查看linux中的chonsen节点会发现竟然有u-boot的bootargs相关内容。

![13](.\pictures\13.png)

那么，u-boot如何传递传输给内核呢？u-boot源码将解析.dtb文件，并在chosen节点，添加bootargs这一个属性。
```
u-boot fdt_support.c文件中
/* find or create "/chosen" node. */
	nodeoffset = fdt_find_or_add_subnode(fdt, 0, "chosen");
	if (nodeoffset < 0)
		return nodeoffset;
```
chosne节点在u-boot的调用关系
![14](.\pictures\14.png)

通过分析源码还可以发现，.dtb文件没有chosen节点貌似没有，应为u-boot源码会自动添加

### 标准属性
节点里面描述了一堆属性，节点不同，描述的属性也自然不同。属性应当根据具体设备进行具体的分卸和书写，但有一些属性是约定俗成的标准属性。

* **compartible属性**

compatible 属性也叫做“兼容性”属性，这是非常重要的一个属性，几乎每个节点都有这个属性。**compatible 属性用于将设备和驱动绑定起来**。

compartible属性的值可以有很多个，每一个用逗号隔开，且其中可能有一个或者多个值是对应某一个具体外设的结构体函数的`.compatible`变量。也即表明该设备是可以支持这个驱动的。

如
```
/*imx6ull.dts*/
sound {
		compatible = "fsl,imx6ul-evk-wm8960",
			   "fsl,imx-audio-wm8960";
		...
}
```
属性值有两个，分别为“fsl,imx6ul-evk-wm8960”和“fsl,imx-audio-wm8960”，其中“fsl”
表示厂商是飞思卡尔，“imx6ul-evk-wm8960”和“imx-audio-wm8960”表示驱动模块名字。sound
这个设备首先使用第一个兼容值在 Linux 内核里面查找，看看能不能找到与之匹配的驱动文件，
如果没有找到的话就使用第二个兼容值查。

fsl,imx-audio-wm8960这一驱动在`imx-wm8969.c`的驱动文件中存在
```
static const struct of_device_id imx_wm8960_dt_ids[] = {
	{ .compatible = "fsl,imx-audio-wm8960", },
	{ /* sentinel */ }
};
```
表明imx-wm8969这个设备支持这一驱动

* **model属性**
model 属性值也是一个字符串，一般 model 属性描述设备模块信息，比如名字什么的。

* **status属性**
表示该节点设备的状态信息。可选的值如下

![15](.\pictures\15.png)

* **#address-cells 和#size-cells 属性**
这两个属性配合设置子节点中 `reg属性`。子节点中`reg属性`一般和地址有关，它一般表明一块地址

```
reg = <address1 length1 address2 length2 address3 length3……>
```
每对`address length`表示一个地址范围，address表示起始地址， length表示地址长度。想要表示一个地址范围，就差一个单位问题了。，由父节点的#address-cells 和#size-cells 决定。即`#address-cells = <1>表示reg属性中address的单位是32位 #size-cells = <1>表示这个reg中lengh数据所占的32位。`

**这里极容易混淆，做如下简化解释，reg 后面的值每个都是32位，#address-cells将表示前几个32位是地址，后面几个32位的归size-cells，以此类推**

```
aips2: aips-bus@02100000 {
			compatible = "fsl,aips-bus", "simple-bus";
			#address-cells = <1>;
			#size-cells = <1>;
			...
			usbotg1: usb@02184000 {
				compatible = "fsl,imx6ul-usb", "fsl,imx27-usb";
				reg = <0x02184000 0x200>;
				...
			}
		...
}
```
aips节点已经表明是所有子节点reg中地址长度32位，起始地址是32位的。那么usbotg1引用的节点`reg = <0x02184000 0x200>;`表示reg中第一个32位数据是地址信息，为0x02184000，后一个32位位地址长度512个

* **reg属性**
前面已经提到，不在赘述

* **ranges 属性**
在arm中不常见

ranges属性值可以为空或者按照(child-bus-address,parent-bus-address,length)格式编写的数字
矩阵，ranges 是一个地址映射/转换表，ranges 属性每个项目由子地址、父地址和地址空间长度
这三部分组成：

child-bus-address：子总线地址空间的物理地址，由父节点的#address-cells 确定此物理地址
所占用的字长。

parent-bus-address：父总线地址空间的物理地址，同样由父节点的#address-cells 确定此物
理地址所占用的字长。

length：子地址空间的长度，由父节点的#size-cells 确定此地址长度所占用的字长。

### 根节点的一些属性
* **根节点 compatible 属性**
用于给内核提供是否支持该.dtb文件的开发板设备的信息。
```
 / {
	model = "Freescale i.MX6 ULL 14x14 EVK Board";
	compatible = "fsl,imx6ull-14x14-evk", "fsl,imx6ull";
	...
}
```

在mach0imx6ul.c中定义了
```
#define DT_MACHINE_START(_name, _namestr)		\
static const struct machine_desc __mach_desc_##_name	\
 __used							\
 __attribute__((__section__(".arch.info.init"))) = {	\
	.nr		= ~0,				\
	.name		= _namestr,

#endif

static const char *imx6ul_dt_compat[] __initconst = {
	"fsl,imx6ul",
	"fsl,imx6ull",
	NULL,
};

DT_MACHINE_START(IMX6UL, "Freescale i.MX6 Ultralite (Device Tree)")
	.map_io		= imx6ul_map_io,
	.init_irq	= imx6ul_init_irq,
	.init_machine	= imx6ul_init_machine,
	.init_late	= imx6ul_init_late,
	.dt_compat	= imx6ul_dt_compat,
MACHINE_END
```
`DT_MACHINE_START`定义的结构体中，最后的`.dt_compat	= imx6ul_dt_compat,`中存储的字符将编译进内核，在启动内核后和.dts中根节点下的`compatible属性`进行比较，参看是否支持。在内核中的`__section__(".arch.info.init"`段将存储支持的linux内核的比较信息

具体实现详见手册.简要的检查调用如图所示
![16](.\pictures\16.png)

同一节点的属性在不同的地方调用，描述相同的属性就会覆盖原来的属性。如在imx6ull.dst中引用的`skeleton.dtsi`内容如下

```
/ {
        #address-cells = <1>;
        #size-cells = <1>;
        chosen { };
        aliases { };
        memory { device_type = "memory"; reg = <0 0>; };
};
```
而在`imx6ull.dst`中，对属性进行了覆盖
```
/{
	...
	memory {
		reg = <0x80000000 0x20000000>;
	};
	...
}
```
那么memory节点最终变成了
```
  memory { device_type = "memory"; reg = <0x80000000 0x20000000>; };
```

## 设备树在系统中的体现
系统启动以后，linux内核会自动解析设备树文件中各个节点的信息，并在根文件`/proc/device-tree`中创建不同的文件夹
![12](.\pictures/12.png)

device-tree存储了所有的的开发板外设数据。这是目录下linux内核解析出的是`imx6ull.dts`的一级子节点,只需进入一级子节点就可以查看这些子节点下的嵌套子节点。均能一一对应dts里面的描述和imx6ull参考手册外设的嵌套关系(如aips里面就规定了有PWM等具体外设)

## 绑定信息文档
相同的设备可能供应商不同而设备启动不同，那么它们的设备树也不同。那么需要写一些文档来详细说明开发板外设的设备树信息是符合定义和编写的。在linux源码的录/Documentation/devicetree/bindings下。

如i2c下面，就有不同的开发商写的关于自身开发板的i2c设备树描述文档

![17](.\pictures/17.png)

需要注意的是，有些文档可能有，有些没有写设备树，那就要考自己了。

## OF操作函数

设备树描述了设备的详细信息，这些信息包括数字类型的、字符串类型的、数组类型的，我们在编写驱动的时候需要获取到这些信息.前面都在介绍内核如何获得dtb信息，那驱动如何获得设备树节点中的信息呢？

Linux 内核给我们提供了一系列的函数来获
取设备树中的节点或者属性信息，这一系列的函数都有一个统一的前缀“of_”，所以在很多资
料里面也被叫做 OF 函数。这些 OF 函数原型都定义在 include/linux/of.h 文件中

of函数用于提取节点信息和属性的函数很多，实际常用的需要掌握。

### 查找节点的OF函数
查找节点的of函数一般有`of_find_node_by_type`
```
首先来看看熟悉又默认的`device_node`结构体
```
struct device_node {
	const char *name; /*节点名字*/
	const char *type; /*设备类型*/
	phandle phandle; 
	const char *full_name; /*节点全名*/
	struct fwnode_handle fwnode;

	struct	property *properties; /*属性*/
	struct	property *deadprops;	/* removed properties */
	struct	device_node *parent; /*父节点*/
	struct	device_node *child; /*子节点*/
	struct	device_node *sibling;
	struct	kobject kobj;
	unsigned long _flags;
	void	*data;
#if defined(CONFIG_SPARC)
	const char *path_component_name;
	unsigned int unique_id;
	struct of_irq_controller *irq_trans;
#endif
};
```
`device_node`就是提供了一个描述设备详细信息的结构体，可以用来查找也可以作为返回值返回查到的节点

```
* `of_find_node_by_type` 通过节点名找节点

接下来介绍查找节点函数`of_find_node_by_type`
```
static inline struct device_node *of_find_node_by_type(struct device_node *from,
	const char *type)
{
	return NULL;
}
```
* from:开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。

* name：要查找的节点名字

* `of_find_node_by_type`通过节点类型找节点
of_find_node_by_type 函数通过 device_type 属性查找指定的节点，但device_type属性在新版的linux中大多已弃用，不推荐使用

```
static inline struct device_node *of_find_node_by_type(struct device_node *from,
	const char *type)
{
	return NULL;
}
```

* type：要查找的节点对应的 type 字符串，也就是 device_type 属性值。

* `of_find_compatible_node` 通过兼容性查找

of_find_compatible_node 函数根据 device_type 和 compatible 这两个属性查找指定的节点
```
static inline struct device_node *of_find_compatible_node(
						struct device_node *from,
						const char *type,
						const char *compat)
{
	return NULL;
}
```

* type：要查找的节点对应的 type 字符串，也就是 device_type 属性值，可以为 NULL，表示
忽略掉 device_type 属性。

* compatible：要查找的节点所对应的compatible 属性列表

* `of_find_node_by_path`

最准确的查找节点方式，通过路径查找
```
static inline struct device_node *of_find_node_by_path(const char *path)
{
	return of_find_node_opts_by_path(path, NULL);
}
```

* path：带有全路径的节点名，可以使用节点的别名，比如“/backlight”就是 backlight 这个
节点的全路径。但路径节点必须符合.dst中的节点嵌套关系

以上函数的返回值都是` device_node *`，返回NULL就是失败了，其他就是返回找到的节点


### 查找属性值的OF函数
节点的属性信息里面保存了驱动所需要的内容，因此对于属性值的提取非常重要，Linux 内
核中使用结构体 property 表示属性，此结构体同样定义在文件 include/linux/of.h 中。如下
```
struct property {
	char	*name;
	int	length;
	void	*value;
	struct property *next;
	unsigned long _flags;
	unsigned int unique_id;
	struct bin_attribute attr;
};
```

* `of_find_property`
```
static inline struct property *of_find_property(const struct device_node *np,
						const char *name,
						int *lenp)
{
	return NULL;
}
```
* np：设备节点。

* name： 属性名字。

* lenp：属性值的字节数

* 返回值：找到的属性。

* `of_property_count_elems_of_size`
```
static inline int of_property_count_elems_of_size(const struct device_node *np,
			const char *propname, int elem_size)
{
	return -ENOSYS;
}
```

* `of_property_read_u32_index`

```
static inline int of_property_read_u32_index(const struct device_node *np,
			const char *propname, u32 index, u32 *out_value)
{
	return -ENOSYS;
}
```

* `of_property_read_ux_array`

`of_property_read_ux_array`中x可以是8 ， 16 ，32 ，64即有四个这样的函数，是`of_property_read_u32_index`的升级版，可以一次性读完全部属性值，适合属性值是数字形式的查找

* `of_property_read_ux`
x可以是8 ， 16 ，32 ，64即有四个这样的函数。适合属性值是单个值的查找

之后还有很多API函数，如有遗漏，在之后的学习中会指出说明。

本节的重点是**查找节点和对应的属性值**,在后续会经常使用

## 设备树驱动简单试验
节后上述说明，给出如下样例代码
```
/*
 * 4 设备树驱动试验
 * 驱动端程序
*/

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/fs.h>
#include <linux/uaccess.h> //调用copy_to_user要用到
#include <linux/io.h>
#include <linux/cdev.h>
#include <linux/device.h> //调用设备驱动用到
#include <linux/of.h> //调用of函数会用到
#include <linux/slab.h> //调用kmalloc kfree要用到

// backlight {
// 		compatible = "pwm-backlight";
// 		pwms = <&pwm1 0 5000000>;
// 		brightness-levels = <0 4 8 16 32 64 128 255>;
// 		default-brightness-level = <7>;
// 		status = "okay";
// };


static int __init dtsof_init(void){
    int ret = 0;
    struct device_node *bl_nd = NULL; /*背光设备节点*/
    struct property *comppro = NULL;
    const char* name;
    int default_val;
    u32 *bl_val;
    u32 elemsize;
    printk("regiter dtsof_init\r\n");
    
    /*编写设备树驱动*/
    //1找到 backlight节点
    bl_nd = of_find_node_by_path("/backlight");
    if(bl_nd == NULL){
        ret = -EINVAL;
        goto fail_findnd;
    }
    //2获取属性
    comppro = of_find_property(bl_nd,"compatible",NULL);
    if(comppro == NULL){
        ret = -EINVAL;
        goto fail_findpro;
    }
    else{
        printk("get property = %s\r\n" , (char*)comppro->value);
    }

    ret = of_property_read_string(bl_nd,"status",&name);
    if(ret < 0){
        goto fail_rs;
    }
    else{
        printk("get status = %s\r\n" , name);
    }

    ret = of_property_read_u32(bl_nd,"default-brightness-level",&default_val);
    if(ret < 0){
        goto fail_rd32;
    }
    else{
        printk("get default-brightness-level = %d\r\n" , default_val);
    }

    //获取属性值是数组的数组个数
    elemsize =  of_property_count_elems_of_size(bl_nd,"brightness-levels", sizeof(u32));
    if(elemsize < 0){
        ret = -elemsize;
        goto fail_rd32arraysize;
    }
    else{
        printk("get brightness-levels size is = %d\r\n" , elemsize);
    }
    //申请内存
    bl_val = kmalloc(elemsize * sizeof(u32) , GFP_KERNEL);
    if(!bl_val){//申请内存失败
        ret = -ENOMEM;
        goto fail_mem;
    }
    //获取属性值是数组的具体数组值
    ret = of_property_read_u32_array(bl_nd,"brightness-levels",bl_val, elemsize);
    if(ret < 0){
        ret = -EINVAL;
        goto fail_rd32array;
    }
    else{
        int i = 0;
        printk("get brightness-levels = ");
        for( ;i < 8;i++){
            printk("%d " , bl_val[i]);
        }
        printk("\r\n");
    }
    kfree(bl_val);

    return 0;
    
fail_mem:
    kfree(bl_val); /*释放内存*/
fail_rd32array:
fail_rd32arraysize:
fail_rd32:
fail_rs:
fail_findpro:
fail_findnd:
    return ret;

}

static void __exit dtsof_exit(void){

}


module_init(dtsof_init);
module_exit(dtsof_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("constant_z");
```
### 获取设备树属性
获取属性成功如下

![18](.\pictures\18.png)


### 动态申请内存
使用`kmalloc`和`kfree`来实现内核中内存的动态申请

![19](.\pictures\19.png)

# 8 新LED驱动
使用设备树来描述开发板的led，来实现LED驱动

## 在.dts中创建设备树节点
新添加的节点一般加到根节点下，不要嵌套在太深的区域。在根节点下，添加如下的子节点代码
```
/*constant_z 2024/6/22*/
	alphaled{
		compatible = "alientek,alphaled";
		#address-cells = <1>;
		#size-cells = <1>;
		status = "okay";
		reg = <0X020C406C 0x4 0X020E0068 0x4 0X020E02F4 0x4 0X0209C000 0x4 0X0209C004 0x4>; /*LED寄存器地址*/
	};
```
对其中的属性做一些介绍

* compatible 

用以描述兼容性的。在本例程中没用到。但可以使用这个属性在驱动中先读取出来，看是否适配板子

* address-cells #size-cells 

用以给子节点的寄存器描述地址及其范围用。实际没用到

* status 

用以描述设备树节点状态的。一般不是热插拔设备都是okay。

* reg

本节最重要的属性，用以描述寄存器地址和它所占的字节数。

创建节点成功后如下图所示

![20](.\pictures\20.png)

接下来，就可以在驱动端写相关的驱动了。字符设备驱动的编写大差不差。就是分配设备号、注册字符设备、和挂载设备节点三步。所以不作展示。

下面说明如何读取设备树信息和使用

要读取设备树节点的信息首先要得到节点。得到节点的方法很多，但这里通过路径获得。**即.dts中设备树节点的绝对路径** 使用`of_find_node_by_path`。参数如下
```
static inline struct device_node *of_find_node_by_path(const char *path)
{
	return NULL;
}
```

* path : 绝对路径

对照本例程的.dts，绝对路径就是`/alphaled`

返回一个设备树节点的指针

有了节点以后就可以读取节点的属性和它的信息了。使用配套的of函数即可，这里不在赘述，直接提供代码
```
 /*4 获取设备树节点信息*/
    dtsled.nd = of_find_node_by_path("/alphaled");//注意是全路径
    if(dtsled.nd == NULL){ //获取失败
        printk("fail to access device nod info\r\n");
        ret = -EINVAL;
        goto fail_fdnd;
    }

    //4.2获取属性信息
    ret = of_property_read_string(dtsled.nd , "status" , &str);
    if(ret < 0){//获取失败
        printk("fail to access device status\r\n");
        goto fail_rs;
    }
    else{
        printk("device status = %s \r\n" , str);
    }
    ret = of_property_read_string(dtsled.nd , "compatible" , &str);
    if(ret < 0){//获取失败
        printk("fail to access device compatible\r\n");
        goto fail_rs;
    }
    else{
        printk("device compatible = %s \r\n" , str);
    }


    //4.3 获取reg属性 最关键的一点
    ret = of_property_read_u32_array(dtsled.nd , "reg" ,reg_data , 10);
    if(ret < 0){
        ret = -EINVAL;
        printk("fail to access reg info\r\n");
        goto fail_rs;
    }
    else{
        u32 i = 0;
        printk("reg = ");
        for(; i < 10; i++){
            printk("%#x ", reg_data[i]);
        }
        printk("\r\n");
    }
```

显然，读取了设备树节点中Led的寄存器信息，接下来就是操作led寄存器的代码了.

```
//5 获取到属性值后，便是正常的LED初始化//
#if 0
    /*LED初始化*/
    IMX6ULL_CCM_CCGR1_BASE = ioremap(reg_data[0], reg_data[1]);//CCGR1 4字节
    IMX6ULL_SW_MUX_GPIO1_IO03 = ioremap(reg_data[2], reg_data[3]);
    IMX6ULL_SW_PAD_GPIO1_IO03 = ioremap(reg_data[4] , reg_data[5]);
    IMX6ULL_GPIO1_DR_BASE = ioremap(reg_data[6] , reg_data[7]);
    IMX6ULL_GPIO1_GDIR_BASE = ioremap(reg_data[8] , reg_data[9]);
#endif

    IMX6ULL_CCM_CCGR1_BASE = of_iomap(dtsled.nd , 0);//特别注意第二参数是按对来算的
    IMX6ULL_SW_MUX_GPIO1_IO03 = of_iomap(dtsled.nd , 1);
    IMX6ULL_SW_PAD_GPIO1_IO03 = of_iomap(dtsled.nd , 2);
    IMX6ULL_GPIO1_DR_BASE = of_iomap(dtsled.nd , 3);
    IMX6ULL_GPIO1_GDIR_BASE = of_iomap(dtsled.nd , 4);
     //使能时钟
    writel(0xffffffff , IMX6ULL_CCM_CCGR1_BASE);

    //配置复用属性
    writel(0x5 , IMX6ULL_SW_MUX_GPIO1_IO03);

    //配置电气属性
    writel(0x10b0,IMX6ULL_SW_PAD_GPIO1_IO03);

    //配置IO输出
    writel(1 << 3,IMX6ULL_GPIO1_GDIR_BASE);

    //输出低电平 默认点亮
    writel(0 << 3 , IMX6ULL_GPIO1_DR_BASE);
```

驱动端成功写入后如图所示
![21](.\pictures\21.png)

驱动端还需要注意的一点是**编写好后，多在linux中重复加载卸载几次，避免一些驱动bug未能即使释放一些资源导致报错**


`of_iomap`可以直接从设备树中回去reg的虚拟地址
```
void __iomem *of_iomap(struct device_node *node, int index)
{
	struct platform_device *op = of_find_device_by_node(node);
	struct resource *r;

	if (!op || index >= op->num_resources)
		return NULL;

	r = &op->archdata.resource[index];

	return of_ioremap(r, 0, resource_size(r), (char *) r->name);
}
```
* **index**

**特别注意，这个index是按对算的，即一个#address-cells 和#size-cells 算一对,不要混淆成数组下标**


# 9 gpio和pinctrl子系统
在linux中操作寄存器几乎是不可能的，操作GPIO这种极其简单的外设，Linux提供了完善的驱动开发框架来实现.基本不会使用第八节这样的代码去操控GPIO

## 9.1 pinctrl子系统
pinctrl子系统用来设置一个Pin的复用和电气属性

pinctrl 子系统主要工作内容如下：

（1）获取设备树中 pin 信息。

（2）根据获取到的 pin 信息来设置 pin 的复用功能

（3）根据获取到的 pin 信息来设置 pin 的电气特性，比如上/下拉、速度、驱动能力等

具体的实现功能是半导体厂商帮我们写好了。相关内容写在设备树文件中。

```
iomuxc: iomuxc@020e0000 {
				compatible = "fsl,imx6ul-iomuxc";
				reg = <0x020e0000 0x4000>;
			};
```

在imx6ull-alientek-emmc.dts又追加写了很多的节点信息
```
&iomuxc {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_hog_1>;
	imx6ul-evk {
		pinctrl_hog_1: hoggrp-1 {
			fsl,pins = <
				MX6UL_PAD_UART1_RTS_B__GPIO1_IO19	0x17059 /* SD1 CD */
				MX6UL_PAD_GPIO1_IO05__USDHC1_VSELECT	0x17059 /* SD1 VSELECT */
				MX6UL_PAD_GPIO1_IO00__ANATOP_OTG1_ID    0x13058 /* USB_OTG1_ID */
			>;
		};
	....

	pinctrl_gpio_leds: gpio-leds {
			fsl,pins = <
				MX6UL_PAD_GPIO1_IO03__GPIO1_IO03	0x17059
			>;
		};
	.....
	}
}
```
不同的外设使用的 PIN 不同、其配置也不
同，因此一个萝卜一个坑，将某个外设所使用的所有 PIN 都组织在一个子节点里面。不同的子节点中寄存器的地址及管教复用以属性的形式已经写好，供linux内核解析和linux系统调用。

引脚的宏定义在 arch/arm/boot/dts/imx6ul-pinfunc.h定义，且引脚的宏定义有嵌套调用的关系。同一引脚，根据管教复用有不同的宏定义，根裸机开发差不多

下面以`MX6UL_PAD_UART1_RTS_B__GPIO1_IO19`这个引脚宏，来看看具体参数及其意义

```
#define MX6UL_PAD_UART1_RTS_B__GPIO1_IO19 0x0090 0x031C 0x00000x5 0x0
```
前面的`MX6UL_PAD_UART1_RTS_B`表示管脚，后面`GPIO1_IO19`表示复用功能。对照技术手册，来看看具体的参数含义

![22](.\pictures\22.png)

接下里就是参数了
```
< 0x0090 0x031C   0x0000    0x5      0x0 >
<mux_reg conf_reg input_reg mux_mode input_val>

```
mux_reg ：复用寄存器地址，即`IOMUXC_SW_MUX_CTL_PAD_UART1_RTS_B`这个地址，但它是**相对于父节点IOMUXC的偏移地址**

conf_reg：配置寄存器，即`SW_PAD_CTL_PAD_UART1_RTS_B SW PAD`电气属性寄存器的地址。但它是**相对于父节点IOMUXC的偏移地址**最后宏定义中的 0x17059就是写给conf_reg值的

input_reg: 有些外设有input_reg 寄存器，有些没有。复用没用到的没有一般写0

mux_mode ：复用模式。对照 上图的`MUX_MODE`可得

input_val： 写入input_reg寄存器的值

### 9.1.1 pinctrl驱动
所有的东西都已经准备好了，包括寄存器地址和寄存器值，Linux 内核相应的驱动文件就会根据这些值来做相应的初始化。接下来就是pinctrl驱动干的事情了

首先的问题就是如何找到这个驱动？通过`compatible`属性，但设备树节点的`compatible`属性和驱动里面的`compatible`属性匹配后，成功后就加载pinctrl驱动了里面的程序了。

pinctrl驱动写在 ，源码如下
```
static struct of_device_id imx6ul_pinctrl_of_match[] = {
	{ .compatible = "fsl,imx6ul-iomuxc", .data = &imx6ul_pinctrl_info, },
	{ .compatible = "fsl,imx6ull-iomuxc-snvs", .data = &imx6ull_snvs_pinctrl_info, },
	{ /* sentinel */ }
};

static int imx6ul_pinctrl_probe(struct platform_device *pdev)
{
	const struct of_device_id *match;
	struct imx_pinctrl_soc_info *pinctrl_info;

	match = of_match_device(imx6ul_pinctrl_of_match, &pdev->dev);

	if (!match)
		return -ENODEV;

	pinctrl_info = (struct imx_pinctrl_soc_info *) match->data;

	return imx_pinctrl_probe(pdev, pinctrl_info);
}

static struct platform_driver imx6ul_pinctrl_driver = {
	.driver = {
		.name = "imx6ul-pinctrl",
		.owner = THIS_MODULE,
		.of_match_table = of_match_ptr(imx6ul_pinctrl_of_match),
	},
	.probe = imx6ul_pinctrl_probe,
	.remove = imx_pinctrl_remove,
};
```
of_device_id
里面保存着这个驱动文件的兼容性值，设备树中的 compatible 属性值会和 of_device_id 中的所
有兼容性字符串比较，查看是否可以使用此驱动。imx6ul_pinctrl_of_match 结构体数组一共有两
个兼容性字符串，分别为“fsl,imx6ul-iomuxc”和“fsl,imx6ull-iomuxc-snvs”，因此 iomuxc 节点与此驱动匹配，所以 pinctrl-imx6ul.c 会完成 I.MX6ULL 的 PIN 配置工作。

当设备和驱动匹配成功以后 platform_driver 的 probe 成员变量所代表的函数就会执行。probe 成员变
量为 imx6ul_pinctrl_probe 函数，因此在本章实验中 imx6ul_pinctrl_probe 这个函数就会执行，可
以认为 imx6ul_pinctrl_probe 函数就是 I.MX6ULL 这个 SOC 的 PIN 配置入口函数。

imx6ul_pinctrl_probe执行流程如下

![23](.\pictures\23.png)

**以上的内容涉及以后的平台设备驱动知识，不懂先有印象，学完了再回来即可**


## 9.2 gpio子系统
gpio子系统用于使用gpio管脚。。gpio 子系统顾名思义，就是用于初始化 GPIO 并且提供相应的 API 函数，比如设置 GPIO为输入输出，读取 GPIO 的值等。gpio 子系统的主要目的就是方便驱动开发者使用 gpio，驱动
开发者在设备树中添加 gpio 相关信息，然后就可以在驱动程序中使用 gpio 子系统提供的 API
函数来操作 GPIO，Linux 内核向驱动开发者屏蔽掉了GPIO 的设置过程，极大的方便了驱动开发者使用 GPIO。

值得注意的是**只有管教被复用 为GPIO，使用GPIO子系统才是正确的**

以节点`hoggrp`的SD1管教为例来说说明
```
pinctrl_hog_1: hoggrp-1 {
			fsl,pins = <
				MX6UL_PAD_UART1_RTS_B__GPIO1_IO19	0x17059 /* SD1 CD */
				MX6UL_PAD_GPIO1_IO05__USDHC1_VSELECT	0x17059 /* SD1 VSELECT */
				MX6UL_PAD_GPIO1_IO00__ANATOP_OTG1_ID    0x13058 /* USB_OTG1_ID */
			>;
		};
```
该节点的管脚 SD1 CD的代码如下
```
&usdhc1 {
	pinctrl-names = "default", "state_100mhz", "state_200mhz";
	pinctrl-0 = <&pinctrl_usdhc1>;
	pinctrl-1 = <&pinctrl_usdhc1_100mhz>;
	pinctrl-2 = <&pinctrl_usdhc1_200mhz>;
	cd-gpios = <&gpio1 19 GPIO_ACTIVE_LOW>;
	keep-power-in-suspend;
	enable-sdio-wakeup;
	vmmc-supply = <&reg_sd1_vmmc>;
	no-1-8-v;
	status = "okay";
};
```
* `pinctrl-0/1/2`是配置GPIO的电气属性

* `cd-gpios`定义这个属性用来专门描述管脚是GPIO功能，后面的值`<&gpio1 19 GPIO_ACTIVE_LOW>`

首先第一部分是`&gpio1`即引用gpio1节点
```
gpio1: gpio@0209c000 {
				compatible = "fsl,imx6ul-gpio", "fsl,imx35-gpio";
				reg = <0x0209c000 0x4000>;
				interrupts = <GIC_SPI 66 IRQ_TYPE_LEVEL_HIGH>,
					     <GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH>;
				gpio-controller;
				#gpio-cells = <2>;
				interrupt-controller;
				#interrupt-cells = <2>;
			};
```
gpio1节点里面描述了关于GPIO控制寄存器的地址等属性
显然是给linux内核告诉gpio1的地址

第二部分，由下面的`#gpio-cells = <2>;`指定，即必须是`&gpio1 19`两个值，第一个参数表示管脚组，第二参数表示管脚号。`#interrupt-cells = <2>`同理，但该部分未给出.注意**GPIO_ACTIVE_LOW定义为1，即低电平用1表示，高电平用0表示**

根据上面这些信息，SD 卡驱动程序就可以使用 GPIO1_IO19 来检测 SD 卡的 CD 信号了。

### gpio子系统驱动
以上介绍的gpio设备树信息如何被linue内核调用呢？这就是gpio子系统驱动的活了。

gpio驱动在drivers/gpio目录下，`gpioxxx.c`即为具体某一芯片的底层gpio源文件。`gpio-mxc.c`即为NXP适配的底层GPIO文件。该文件下还有`gpiolib`等lib文件，就是给linux内核用的，用于解析`gpioxxx.c`的内容，并向上提供给驱动层一些API函数以调用物理的gpio关键，这就是`gpioapi.c`等api函数源文件

比如 在`gpiolib.c`中就规定gpio注册需要`int gpiochip_add(struct gpio_chip *chip)`这个函数，那么底层`gpio-mxc.c`就必须实现`struct gpio_chip *chip`这样一个结构体。

大致流程如下：

首先，设备树中的`.compatible`属性会和各个文件中的`gpio-xxxc.c`来进行比较.

比如`mx6ull.dtsi`中的gpio1的`compatible = "fsl,imx6ul-gpio", "fsl,imx35-gpio";`那么`fsl,imx35-gpio`就和`gpio-mxc.c`中的`.compatible = "fsl,imx35-gpio", .data = &mxc_gpio_devtype[IMX35_GPIO], `匹配成功，那么就表明该文件就是设备树中`gpio1`的驱动源文件。

接下来，就是将驱动文件在linux内核中进行注册，执行平台驱动注册函数`mxc_gpio_probe`
```
static struct platform_driver mxc_gpio_driver = {
	.driver		= {
		.name	= "gpio-mxc",
		.of_match_table = mxc_gpio_dt_ids,
	},
	.probe		= mxc_gpio_probe,
	.id_table	= mxc_gpio_devtype,
};
```

## 试验验证
### dts中编写节点
首先添加pinctl节点，用以描述GPIO的复用和电气属性配置。注意，pinctrl节点不能随便添加，需要在对应的节点下添加。如imx6ull指定了gpio都是属于iomuxc下，即必须在iomuxc节点在添加pinctrl子节点
![24](.\pictures\24.png)
添加的信息如下：
```
pinctrl_gpioled: ledgrp{
			fsl,pins = <
				MX6UL_PAD_GPIO1_IO03__GPIO1_IO03	0x10b0
			>;
		};
```


接下来.dts的根节点下，添加子节点`gpioled`。代码如下
```
/*constant_z 2024/6/24*/
	gpioled{
		compatible = "alientek,gpioled";
		status = "okay";
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_gpioled>;
		led-gpios = <&gpio1 3 GPIO_ACTIVE_LOW>;
	};
```

前两个属性没用到，不再赘述。

* pinctrl-names: 随便。一般是default

* pinctrl-x

该节点用到几组pinctrl，x就从0开始编号。且需按照代码中的格式一样<&pinctrl节点名> 

* led-gpios gpio属性节点

名字随便，但后面的值必须照<&gpio组号 gpio管脚号 默认电平>来写。这个属性要对应驱动端的`of_get_named_gpio`函数

这样，设备树里面的文件就算编写完了。

### 驱动端搭建
驱动的框架前面的申请设备号、注册字符设备和挂载设备节点,创建类、创建设备都是老套路，不在赘述。重点放在如何通过gpio子系统来驱动正确的gpio

主要会用到gpio子系统的三个api函数.

* **获取对应节点的gpio号**

使用`of_get_named_gpio`函数。原型如下
```
static inline int of_get_named_gpio(struct device_node *np,
                                   const char *propname, int index)
{
	return of_get_named_gpio_flags(np, propname, index, NULL);
}
```
* np: 设备节点

* propname: 属性名称

对应.dts根文件下建立的设备节点的文件。

* **申请使用该gpio**

使用`gpio_request`.原型如下：
```
static inline int gpio_request(unsigned gpio, const char *label)
{
	return -ENOSYS;
}
```
* gpio: 对应的gpio号

* label：名字

任意即可。一般用不到

* **GPIO申请失败：**

大概率是GPIO被其他外设占用。这个时候要检查设备树文件.dts，从管脚复用和管脚使用两个方面看

发现管脚复用`MX6UL_PAD_GPIO1_IO03__GPIO1_IO03`还在`pinctrl_tsc`用到了，所以会报错。因为这个是NXP电阻屏的管脚，所以没有用到，直接屏蔽

再者，检查GPIO的使用情况，即检查`<&gpio1 3 GPIO_ACTIVE_LOW>`在设备树文件中有没有被用到。还用到了`tsc`，所以注释即可。

所以，**再申请GPIO号后请务必检查占用情况**

* **使用IO**

前面的环节打通过后就可以驱动IO了，使用`gpio_direction_output`和`gpio_set_value`来控制GPIO的输入输出
```
static inline int gpio_direction_output(unsigned gpio, int value)
{
	return -ENOSYS;
}
```

`gpio_direction_output`用于设备某个gpio为输出。是gpio作为输出时必须使用的函数

`gpio_set_value`驱动端用于设备gpio高低电平的函数

详细的驱动端初始化代码如下：
```
static int __init led_init(void){
    int ret;
    printk("start to init gpioled\r\n");
    //注册字符设备驱动
    gpioled.major = 0;
    if(gpioled.major){
        gpioled.devid = MKDEV(gpioled.major , 0);
        register_chrdev_region(gpioled.devid , GPIOLED_CNT , GPIOLED_NAME);
    }
    else{ /*自动分配设备号*/
        alloc_chrdev_region(&gpioled.devid , 0 ,GPIOLED_CNT ,  GPIOLED_NAME);
    }
    gpioled.major = MAJOR(gpioled.devid);
    gpioled.minor = MINOR(gpioled.devid);
    printk("gpioled major = %d minor = %d\r\n",gpioled.major , gpioled.minor);

    //初始化字符cdev
    gpioled.mycdev.owner =  THIS_MODULE;
    cdev_init(&gpioled.mycdev , &led_fops);
    ret = cdev_add(&gpioled.mycdev , gpioled.devid , GPIOLED_CNT);
    if(ret < 0){
        printk("fail to access cdev\r\n");
    }

    //创建类
    gpioled.myclass = class_create(THIS_MODULE, GPIOLED_NAME);
    if(IS_ERR(gpioled.myclass)){
        printk("fail to create class\r\n");
        return PTR_ERR(gpioled.myclass);
    }

    //创建设备
    gpioled.mydevice = device_create(gpioled.myclass, NULL, gpioled.devid, NULL,GPIOLED_NAME);
    if(IS_ERR(gpioled.mydevice )){
        printk("fail to create device\r\n");
        return PTR_ERR(gpioled.mydevice );
    }

    //gpio相关操作
    //获取设备节点
    gpioled.nd = of_find_node_by_path("/gpioled");
    if(gpioled.nd == NULL){
        printk("fail to access device node\r\n");
        ret = -EINVAL;
        goto fail_fdnd;
    }
    //获取LED所对应的gpio
    gpioled.led_gpio = of_get_named_gpio(gpioled.nd , "led-gpios" , 0);
    if(gpioled.led_gpio < 0){
        printk("fail to access property name\r\n");
        ret = -EINVAL;
        goto  fail_fnnm;
    }
    printk("led gpio num = %d\r\n",gpioled.led_gpio);
    //申请GPIO
    ret = gpio_request(gpioled.led_gpio , "gpioled.led_gpio");
    if(ret){
        printk("fail to request gpio num\r\n");
        ret = -EINVAL;
        goto fail_getnm;
    }
    //使用IO
    ret = gpio_direction_output(gpioled.led_gpio , 1);//默认高电平 不点亮
    if(ret){
        printk("fail to set gpio output\r\n");
        ret = -EINVAL;
        goto fail_stout;
    }

    gpio_set_value(gpioled.led_gpio , 0); //开启led

    return 0;

fail_stout:
    gpio_free(gpioled.led_gpio);
fail_getnm:
fail_fnnm:
fail_fdnd:
    return ret;
}
```
### 总结
1 添加pinctrl信息

2 编写设备树节点

3 检查是否存在多个程序共用GPIO

4 编写字符设备驱动

5 获取对应GPIO号

6 申请GPIO

7 使用GPIO 



# 10 蜂鸣器试验
理论上仍然是GPIO子系统和pinctrl系统的熟悉。

## 编写设备树

**值得注意的一点是 6ull和6ul的pintrl文件里面的宏定义，SNVS的宏定义地址处是不一样的，一定要对照一下！**



# 11 Linux并发与竞争
Linux是一个多任务操作系统，肯定会存在多个任务共同操作同一段内存或者设备的情况，多个任务甚至中断都能访问的资源叫做共享资源，就和共享单车一样。在驱动开发中要注意对共享资源的保护，也就是要处理对共享资源的并发访问。

## 1.1 并发的简单说明
**并发**是指多个用户或者程序访问同一资源。Linux 系统是个多任务操作系统，会存在多个任务同时访问同一片内存区域，这些任务可
能会相互覆盖这段内存中的数据，造成内存数据混乱。

对于共享数据段(也叫临界区)，对于临界区必须保证一次只有一个线程访问，也就是要保证临界区是原子访问的，注意这里的“原子”不是正点原子的“原子”。原子访问就表示这一个访问是一个步骤，不能再进行拆分。如果多个线程同时操作临界区就表示存在竞争，我们在编写驱动的时候一定要注意避免并发和防止竞争访问。

## 1.2 保护的内容
基于上面的说明，并发中最为重要的是**保护共享的内存资源**。虽然知道了要对共享数据进行保护，那么怎么判断哪些共享数据要保护呢？找到要保护的数据才是重点，而这个也是难点，因为驱动程序各不相同，那么数据也千变万化，一般像全局变量，设备结构体这些肯定是要保护的，至于其他的数据就要根据实际的驱动程序而定了。换而言之，就是具体问题具体分析！

下面介绍常用的保护方法

## 原子操作
原子操作就是指不能再进一步分割的操作，一般原子操作用于变量
或者位操作。

假设有线程均有访问全局变量a的函数。
```
a = 3;
```
转换成汇编代码。
```
ldr r0, =0X30000000 /* 变量 a 地址 */
ldr r1, = 3 /* 要写入的值 */
str r1, [r0] /* 将 3 写入到 a 变量中 */
```
现在，线程A将将a改写成10的时候，线程B访问a并改写成20.则执行如下
![25](.\pictures\25.png)

这样执行的结果就不对了。通过上图，发现关键点在于如何保护汇编的三行代码以一个不可分割的整体去执行，这就是原子操作。Linux内核提供了API函数来实现相关的原子操作

### 原子整型操作
Linux 内核定义了叫做 atomic_t 的结构体来完成整形数据的原子操作，在使用中用原子变量来代替整形变量.在`types.h`中。定义如下
```
typedef struct {
	int counter;
} atomic_t;
```
`atomic_t`以后就代替`int`来实现相关操作了。`atomic_t`的变量赋值操作就不再是`+ - * /`等了，而是一些API函数来实现。
如下图所示

![26](.\pictures\26.png)



### 原子位操作

原子位操作不像原子整形变量那样有个 atomic_t 的数据结构，原子位操作是直接对内存进行操作。相关API函数如下
![27](.\pictures\27.png)


## 锁机制

原子操作所实现的功能还是有限，有没有一种方式是当前线程独占这个共享资源呢？这就是下面所提到的锁机制

### 自旋锁

当一个线程要访问某个共享资源的时候首先要先获取相应的锁，锁只能被一个线程持有，只要此线程不释放持有的锁，那么其他的线程就不能获取此锁。对于自旋锁而言，如果自旋锁正在被线程 A 持有，线程 B 想要获取自旋锁，那么线程 B 就会处于忙循环-旋转-等待状态，线
程 B 不会进入休眠状态或者说去做其他的处理，而是会一直傻傻的在那里“转圈圈”的等待锁可用。

自旋锁的“自旋”也就是“原地打转”的意思，“原地打转”的目的是为了等待自旋锁可以用，可以访问共享资源。把自旋锁比作一个变量 a，变量 a=1 的时候表示共享资源可用，当 a=0的时候表示共享资源不可用。现在线程 A 要访问共享资源，发现 a=0(自旋锁被其他线程持有)，那么线程 A 就会不断的查询 a 的值，直到 a=1。从这里我们可以看到自旋锁的一个缺点：那就等待自旋锁的线程会一直处于自旋状态，这样会浪费处理器时间，降低系统性能，所以自旋锁的持有时间不能太长。**所以自旋锁适用于短时期的轻量级加锁，如果遇到需要长时间持有锁的场景那就需要换其他的方法了**

简而言之**自旋锁就是占用-等待**，类似于程序轮询。

自旋锁以结构体形式调用，为` spinlock_t`,定义如下
```
typedef struct spinlock {
	union {
		struct raw_spinlock rlock;

#ifdef CONFIG_DEBUG_LOCK_ALLOC
# define LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map))
		struct {
			u8 __padding[LOCK_PADSIZE];
			struct lockdep_map dep_map;
		};
#endif
	};
} spinlock_t;
```

使用自旋锁前一定要定义自旋锁，这样在程序中才可以正常使用

```
spinlock_t lock; //定义自旋锁
```

定义完后就可以使用相关的API函数进行资源占用释放的操作了

![28](.\pictures\28.png)

**使用自旋锁，一定要注意死锁现象的发生。**即拥有锁的进程不能中途休眠或者阻塞。原因在于自旋锁会自动禁止抢占，也就说当线程 A
得到锁以后会暂时禁止内核抢占。如果线程 A 在持有锁期间进入了休眠状态，那么线程 A 会自动放弃 CPU 使用权。线程 B 开始运行，线B 也想要获取锁，但是此时锁被 A 线程持有，而且内核抢占还被禁止了！线程 B 无法被调度出去，那么线程 A 就无法运行

那么线程被中断打断呢？分两种情况，第一种，中断不会调用被锁的资源，那么就无事发生。第二种，中断需要使用被锁的资源，就会发生死锁。

最好的解决方法就是获取锁之前关闭本地中断，禁止一些中断来禁止第二种情况的发生，Linux 内核提供了相应的 API 函数。

![29](.\pictures\29.png)

### 自旋锁的使用注意事项

* 因为在等待自旋锁的时候处于“自旋”状态，因此锁的持有时间不能太长，一定要
短，否则的话会降低系统性能。如果临界区比较大，运行时间比较长的话要选择其他的并发处
理方式，比如稍后要讲的信号量和互斥体。

* 自旋锁保护的临界区内不能调用任何可能导致线程休眠的 API 函数，否则的话可能
导致死锁。

* 不能递归申请自旋锁，因为一旦通过递归的方式申请一个你正在持有的锁，那么你就
必须“自旋”，等待锁被释放，然而你正处于“自旋”状态，根本没法释放锁。结果就是自己
把自己锁死了！

* 在编写驱动程序的时候我们必须考虑到驱动的可移植性，因此不管用的是单核的还是多核的 SOC，都将其当做多核 SOC 来编写驱动程序

### 其他自旋锁


## 信号量
自旋锁种一个进程占用共享资源，另一个进程访问时就只能空转等待，这样浪费效率。应该以一种通知的方式来告诉另外一个进程可以使用共享的，这样其他进程还可以忙其他事情。

比喻一下：相比于自旋锁，信号量可以使线程进入休眠状态，比如 A 与 B、C 合租了一套房子，这个房子只有一个厕所，一次只能一个人使用。某一天早上 A 去上厕所了，过了一会 B 也想用厕所，因为 A 在厕所里面，所以 B 只能等到 A 用来了才能进去。B 要么就一直在厕所门口等着，等 A 出来，这个时候就相当于自旋锁。B 也可以告诉 A，让 A 出来以后通知他一下，然后 B 继续回房间睡觉，这个时候相当于信号量。可以看出，使用信号量会提高处理器的使用效率，毕
竟不用一直傻乎乎的在那里“自旋”等待。但是，信号量的开销要比自旋锁大，因为信号量使线程进入休眠状态以后会切换线程，切换线程就会有开销

信号量的特点：

* 、因为信号量可以使等待资源线程进入休眠状态，因此适用于那些占用资源比较久的场
合。

* 因此信号量不能用于中断中，因为信号量会引起休眠，中断不能休眠

* 如果共享资源的持有时间比较短，那就不适合使用信号量了，因为频繁的休眠、切换线程引起的开销要远大于信号量带来的那点优势

信号量的定义如下
```
/* Please don't access any members of this structure directly */
struct semaphore {
	raw_spinlock_t		lock;
	unsigned int		count;
	struct list_head	wait_list;
};
```
信号量的API函数

![30](.\pictures\30.png)

有关linux线程状态的补充

[linux线程状态](https://blog.csdn.net/sdkdlwk/article/details/65938204)


## 互斥量

即二进制信号量，但linux提供了一种专门的结构体来实现互斥量-mutex.互斥访问表示一次只有一个线程可以访问共享资源，不能递归申
请互斥体。

定义如下：
```
struct mutex {
	/* 1: unlocked, 0: locked, negative: locked, possible waiters */
	atomic_t		count;
	spinlock_t		wait_lock;
	struct list_head	wait_list;
#if defined(CONFIG_DEBUG_MUTEXES) || defined(CONFIG_MUTEX_SPIN_ON_OWNER)
	struct task_struct	*owner;
#endif
#ifdef CONFIG_MUTEX_SPIN_ON_OWNER
	struct optimistic_spin_queue osq; /* Spinner MCS lock */
#endif
#ifdef CONFIG_DEBUG_MUTEXES
	void			*magic;
#endif
#ifdef CONFIG_DEBUG_LOCK_ALLOC
	struct lockdep_map	dep_map;
#endif
};
```

专用的API函数

![31](.\pictures\31.png)

### 互斥量的注意事项

* mutex 可以导致休眠，因此不能在中断中使用 mutex，中断中只能使用自旋锁。

* 和信号量一样，mutex 保护的临界区可以调用引起阻塞的 API 函数。

* 因为一次只有一个线程可以持有 mutex，因此，必须由 mutex 的持有者释放 mutex。并且 mutex 不能递归上锁和解锁。


# 12 linux竞争于并发试验

## 原子操作

效果如图所示

![32](.\pictures\32.png)

## 自旋锁操作

效果如图所示
![33](.\pictures\33.png)

## 信号量操作

效果如图所示

![34](.\pictures\34.png)


# 13 Linux按键输入

学习linux下GPIO输入功能的使用，主要通过读取IO状态来实现相关功能，使用中断等方式在后面会重点介绍。

按键驱动和 LED 驱动原理上来讲基本都是一样的，都是操作 GPIO，只不过一个是读取
GPIO 的高低电平，一个是从 GPIO 输出高低电平。本章我们实现按键输入，在驱动程序中使用
一个整形变量来表示按键值，应用程序通过 read 函数来读取按键值，判断按键有没有按下。在
这里，这个保存按键值的变量就是个共享资源，驱动程序要向其写入按键值，应用程序要读取
按键值。所以我们要对其进行保护，对于整形变量而言我们首选的就是原子操作，使用原子操
作对变量进行赋值以及读取。

## 程序编写
### 修改设备树

# 14 Linux内核定时器

## Linux时间管理介绍

Linux 内核中有大量的函数需要时间管理，比如周期性的调度程序、延时程序、对于驱动编写来说最常用的定时器。硬件定时器提供时钟源，时钟源的频率可以设置， 设置好以后就周期性的产生定时中断，系统使用定时中断来计时。中断周期性产生的频率就是系统频率，也叫做节拍率(tick rate)(有的资料也叫系统频率)，比如 1000Hz，100Hz 等等说的就是**系统节拍率**。系统节拍率是可以设置的，单位是 Hz，我们在编译 Linux 内核的时候可以通过图形化界面设置系统节拍率。如图所示

![35](.\pictures\35.png)

除了图形界面配置外，还可以在/include/ars-generic/param.h中找到`define HZ`来配置时钟频率

此外，编译好的内核频率可以在源码下的.config文件中查看，参数名称时`CONFIG_HZ`

为什么内核频率相较于cpu主频来说如此低？

* 高节拍率会提高系统时间精度，如果采用 100Hz 的节拍率，时间精度就是 10ms，采用
1000Hz 的话时间精度就是 1ms，精度提高了 10 倍。高精度时钟的好处有很多，对于那些对时
间要求严格的函数来说，能够以更高的精度运行，时间测量也更加准确。

* 高节拍率会导致中断的产生更加频繁，频繁的中断会加剧系统的负担，1000Hz 和 100Hz
的系统节拍率相比，系统要花费 10 倍的“精力”去处理中断。中断服务函数占用处理器的时间
增加。

**Linux 内核使用全局变量 jiffies 来记录系统从启动以来的系统节拍数，系统启动的时候会将 jiffies 初始化为 0** jiffies在/include/linux/jiffires.h下有定义，原型如下

```
/*
 * The 64-bit value is not atomic - you MUST NOT read it
 * without sampling the sequence number in jiffies_lock.
 * get_jiffies_64() will do this for you as appropriate.
 */
extern u64 __jiffy_data jiffies_64;
extern unsigned long volatile __jiffy_data jiffies;
```

当我们访问 jiffies 的时候其实访问的是 jiffies_64 的低 32 位，使用 get_jiffies_64 这个函数可以获取 jiffies_64 的值。在 32 位的系统上读取 jiffies 的值，在 64 位的系统上 jiffes 和 jiffies_64表示同一个变量，因此也可以直接读取 jiffies 的值。所以不管是 32 位的系统还是 64 位系统，都可以使用 jiffies。

jiffies是变量，溢出后自动清零，术语叫绕回。Linux 内核提供了几个 API 函数来处理绕回

![36](.\pictures\36.png)

jiffies同ms、s 、ns之间，linux同样提供了一些函数供直接转换

![37](.\pictures\37.png)


## 内核定时器介绍

linux内核定时器不是直接调用底层的硬件定时器，而是使用系统时间源的软件定时器是。Linux 内核定时器使用很简单，只需要提供超时时间(相当于定时值，即超时时间点)和定时处理函数即可。但需要注意的是**内核定时器不是周期性的**一次定时时间到了就会关闭，需要再次手动打开。

Linux 内核使用 timer_list 结构体表示内核定时器，timer_list 定义在文件include/linux/timer.h 中，定义如下

```
struct timer_list {
	/*
	 * All fields that change during normal runtime grouped to the
	 * same cacheline
	 */
	struct list_head entry;
	unsigned long expires; /*定时器超时时间 单位是节拍书 */
	struct tvec_base *base;
	void (*function)(unsigned long);/*定时器处理器*/

	unsigned long data;/*需要传递给function的参数*/

	int slack;
}
```

接下来，就是如何使用内核定时器了，Liunx同样提供了很多API函数来实现

* init_timer

* add_timer

* del_timer

* del_timer_sync

* mod_timer

mod_timer不仅会设置定时时间点，还会自动激活定时器

## 内核延时函数

linux内核同样提供了一些Linux内核的短延时函数，用来实现空转

![38](.\pictures\38.png)

## 内核定时试验

利用Linux内核定时器实现led流水灯效果


### 驱动端编写

ioctl是 file_operation 结构体中比较重要的函数之一。它包含`unlocked_ioctl`和`compat_ioctl `两个函数。两个函数均是数提供对于设备的控制功能，与应用程序中的 ioctl 函数对应。

64位系统上，使用32位的应用程序会调用`compat_ioctl`，而32位系统中32位应用程序会调用`unlocked_ioctl`,其他没有差别

`unlocked_ioctl`函数原型如下
```

```

命令是自己定义的，但要符合linux的命令规则

### 应用端编写

# 15 linux 中断

Linux中断更多是编写指定的linux框架，而不是操控底层寄存器来控制CPU的中断。

## linux中断简介

（1）中断号

每个中断都有一个中断号，通过中断号即可区分不同的中断，有的资料也把中断号叫做中断线。在 Linux 内核中使用一个 int 变量表示中断号

(2) 中断申请函数

`requeset_irq`

函数原型如下：


* 首先明确使用中断的中断号

* 申请使用中断后，在去处理中断服务函数

* 不使用中断释放中断号 `free_irq()`

(3) 中断服务函数




(4) 中断使能及中断禁止

`void enable_irq(unsigned int irq)`及中断使能

`void disable_irq(unsigned int irq)`禁止中断

相当于指定中断号的中断开关。`disable_irq`函数要等到当前正在执行的中断处理函数执行完才返回，因此使用者需要保证不会产生新的中断，并且确保所有已经开始执行的中断处理程序已经全部退出。但**一般不同步也没有问题**，或者使用`void disable_irq_nosync(unsigned int irq)`直接不执行完中断函数立即关闭

关闭整个中断系统，类似于关闭逻辑中的GIC中断协处理器`local_irq_enable()`和`local_irq_disable()` 

使用这两个函数必须保证仅一个中断控制，否则多个中断均有能力控制中断开关则会导致中断可能不会按预期打开关闭

## 上半部和下半部

中断的服务函数要求越快越好，提高性能。但实际情况可能有些中断执行确实不能很快，liunx就提出按部分执行这类中断，分成上半部和下半部来提高系统的实时性能。

**上半部**：上半部就是中断处理函数，那些处理过程比较快，不会占用很长时间的处理就可以放在上半部完成。

**下半部**：如果中断处理过程比较耗时，那么就将这些比较耗时的代码提出来，交给下半部去执行，这样中断处理函数就会快进快出

实际的上下半部的划分要根据实际情况处理，但大致要求就如上介绍所示

在使用request_irq 申请中断的时候注册的中断服务函数属于中断处理的上半部，只要中断触发，那么中断处理函数就会执行。那哪些是函数的下半部呢？

### 软中断

Linux 内核使用结构体 softirq_action 表示软中断， softirq_action
结构体定义在文件 include/linux/interrupt.h 中

```
struct softirq_action
{
	void	(*action)(struct softirq_action *);
};
```

liunx已经定义好了10个软中断类型，分装在`softirq_action softirq_vec[NR_SOFTIRQS]`里面 `NR_SOFTIRQS`里面定义如下

```
enum
{
 HI_SOFTIRQ=0, /* 高优先级软中断 */
 TIMER_SOFTIRQ, /* 定时器软中断 */
 NET_TX_SOFTIRQ, /* 网络数据发送软中断 */
 NET_RX_SOFTIRQ, /* 网络数据接收软中断 */
 BLOCK_SOFTIRQ, 
 BLOCK_IOPOLL_SOFTIRQ, 
 TASKLET_SOFTIRQ, /* tasklet 软中断 */
 SCHED_SOFTIRQ, /* 调度软中断 */
 HRTIMER_SOFTIRQ, /* 高精度定时器软中断 */
 RCU_SOFTIRQ, /* RCU 软中断 */
 NR_SOFTIRQS
};
```

**要使用上述中断就要先注册上述中断**，使用`open_softirq `函数执行注册

* `void open_softirq(int nr, void (*action)(struct softirq_action *))`

参数说明：


**软中断必须要编译的时候静态注册**，注册好以后再激活软中断.`raise_softirq`来执行激活

### tasklet

本质是利用软中断来实现的一种下半部机制中断，推荐使用`tasklet`。该机制由结构体` tasklet_struct`来控制，原型如下
```
struct tasklet_struct
{
	struct tasklet_struct *next;
	unsigned long state;
	atomic_t count;
	void (*func)(unsigned long);
	unsigned long data;
};
```

使用步骤 ： 定义一个tasklet函数 -> 初始化对应的处理函数 -> 调用服务函数

tasklet更多像是上下部都有杂糅的中断机制，但使用时效果更好。

### 工作队列

## 中断如何在设备树里面描述

中断在设备树中的描述必须按照严格的配置，对于中断控制器，设 备树 绑定 信息 参考 文档Documentation/devicetree/bindings/arm/gic.txt，参考的中断控制器节点描述如下
```
intc: interrupt-controller@00a01000 {
		compatible = "arm,cortex-a7-gic";
		#interrupt-cells = <3>;
		interrupt-controller;
		reg = <0x00a01000 0x1000>,
		      <0x00a02000 0x100>;
	};
```

* compatible属性

“arm,cortex-a7-gic”在 Linux 内核源码中搜索“arm,cortex-a7-gic”即可找到 GIC 中断控制器驱动文件

* #interrupt-cells

#interrupt-cells 和#address-cells、#size-cells 一样。表示此中断控制器下设备的 cells大小，对于设备而言，会使用 `interrupts` 属性描述中断信息。对于ARM的GIC而言，用三个整型值来描述具体的中断信息。后续的具体中断节点也可以定义`interrupt-cells`来再具体规定子节点的`interrupts`属性信息，再搭配指定父中断节点即可

* #interrupt-parent

指定该设备的父节点是哪个，搭配父节点的`interrupt-cells`来规定子节点的`interrupts`信息用

如gpio5节点可以触发中断，参考的设备树描述如下

```
gpio5: gpio@020ac000 {
				compatible = "fsl,imx6ul-gpio", "fsl,imx35-gpio";
				reg = <0x020ac000 0x4000>;
				interrupts = <GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH>,
					     <GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH>;
				gpio-controller;
				#gpio-cells = <2>;
				interrupt-controller;
				#interrupt-cells = <2>;
			};
```
* interrupts

值就是父节点`intc`规定的三个值。其描述在gic.txt也写的很清楚了。

第一位：及中断类型。0是SPI中断 1是PPI中断

第二位：中断号。对应imx6ull技术手册的中断号

第三位：中断触发类型。

```
The 3rd cell is the flags, encoded as follows:
bits[3:0] trigger type and level flags.
1 = low-to-high edge triggered
2 = high-to-low edge triggered (invalid for SPIs)
4 = active high level-sensitive
8 = active low level-sensitive (invalid for SPIs).
```

以上的部分基本是NXP给我们写好的了，驱动开发者具体要做的就是实现具体节点的设备数编写。如使用GPIO5的中断，那么编写节点就要符合GPIO5设备树信息规定的信息，并指明父节点的信息。具体的参考文档就是gpio-mxs.txt中用到。部分信息如下
```
Required properties for GPIO node:
- compatible : Should be "fsl,<soc>-gpio".  The supported SoCs include
  imx23 and imx28.
- interrupts : Should be the port interrupt shared by all 32 pins.
- gpio-controller : Marks the device node as a gpio controller.
- #gpio-cells : Should be two.  The first cell is the pin number and
  the second cell is used to specify the gpio polarity:
      0 = active high
      1 = active low
- interrupt-controller: Marks the device node as an interrupt controller.
- #interrupt-cells : Should be 2.  The first cell is the GPIO number.
  The second cell bits[3:0] is used to specify trigger type and level flags:
      1 = low-to-high edge triggered.
      2 = high-to-low edge triggered.
      4 = active high level-sensitive.
      8 = active low level-sensitive.
```

## 获取中断号

编写驱动的时候需要用到中断号，中断信息已经写到了设备树里面，因此可以通过 irq_of_parse_and_map 函数从 interupts 属性中提取到对应的设备号
```
static inline unsigned int irq_of_parse_and_map(struct device_node *dev,
						int index)
{
	return 0;
}
```
index就是索引值，interrupts 属性可能包含多条中断信息，通过 index 指定要获取的信息

返回值就是中断号，可以用于定时器等非GPIO中断

更多情况下，如果使用的是GPIO中断，就使用`gpio_to_irq`获取中断号
```
static inline int gpio_to_irq(unsigned gpio)
{
	/* GPIO can never have been requested or set as input */
	WARN_ON(1);
	return -EINVAL;
}
```
返回值就是中断号。

## 中断试验1：按键中断

编写驱动的流程首先就是添加设备树信息->编写驱动->编写应用

### 设备树编写

即更新以下按键的设备数节点，使其支持中断
```
alientekkey{
		compatible = "alientek,beep";
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_key>;
		key-gpios = <&gpio1 18 GPIO_ACTIVE_HIGH>;
		interrupt-parent = <&gpio1>;
		interrupts = <18 IRQ_TYPE_EDGE_BOTH>;
		status = "okay";
	};
```

### 加入定时器消抖


### 下半部中断试验


### container_of函数应用

利用container_of可以在已知子结构体的地址情况下找到父结构体的地址，非常好用。

# 16 Linux 阻塞和非阻塞IO

阻塞和非阻塞 IO 是 Linux 驱动开发里面很常见的两种设备访问模式，这里的IO是输入输出的意思。阻塞式 IO 就会将应用程序对应的线程挂起，直到设备资源可以获取为止。对于非阻塞 IO，应用程序对应的线程不会挂起，它要么一直轮询等待，直到设备资源可以使用，要么就直接放弃。前面的所有试验都是非阻塞IO，这么做回浪费大量的资源

![39](.\pictures\39.png)

阻塞式I0访问


![40](.\pictures\40.png)

非阻塞式I0访问

由上面的图可得，想要使用阻塞io访问，就从2方面修改，用户态->应用程序和内核态->驱动程序

## 应用程序

修改很简单，read访问驱动时时加入O_NONBLOCK即可

## 驱动程序

### 等待队列头

用于存储阻塞访问设备不可用时进入休眠的任务链表，一般在中断中唤醒等待队列头的任务，尝试访问设备。

等待队列头使用结构体`wait_queue_head_t` 表示，`wait_queue_head_t` 结构体定义在文件`include/linux/wait.h`中，结构体内容如下所示

```
struct __wait_queue_head {
	spinlock_t		lock;
	struct list_head	task_list;
};
typedef struct __wait_queue_head wait_queue_head_t;
```

定义了结构体后，需要在驱动程序中初始化，使用`init_waitqueue_head`,函数原型如下

```
#define init_waitqueue_head(q)				\
	do {						\
		static struct lock_class_key __key;	\
							\
		__init_waitqueue_head((q), #q, &__key);	\
	} while (0)

#ifdef CONFIG_LOCKDEP
# define __WAIT_QUEUE_HEAD_INIT_ONSTACK(name) \
	({ init_waitqueue_head(&name); name; })
# define DECLARE_WAIT_QUEUE_HEAD_ONSTACK(name) \
	wait_queue_head_t name = __WAIT_QUEUE_HEAD_INIT_ONSTACK(name)
#else
# define DECLARE_WAIT_QUEUE_HEAD_ONSTACK(name) DECLARE_WAIT_QUEUE_HEAD(name)
#endif
```

声明如下`void init_waitqueue_head(wait_queue_head_t *q)`

### 等待队列项

等待队列头就是一个等待队列的头部，每个访问设备的进程都是一个队列项，当设备不可用的时候就要将这些进程对应的等待队列项添加到等待队列里面。结构体 `wait_queue_t` 表示等待队列项，结构体内容如下

```
struct __wait_queue {
	unsigned int		flags;
	void			*private;
	wait_queue_func_t	func;
	struct list_head	task_list;
};
```

同理，它需要初始化,使用`DECLARE_WAITQUEUE(name, tsk)`，name即等待队列项的名字，tsk 表示这个等待队列项属于哪个任务(进程)，一般设置为current,在 Linux 内核中current相当于一个全局变量，表示当前进程。因此宏`DECLARE_WAITQUEUE`就是给当前正在运行的进程创建并初始化了一个等待队列项

### 将任务添加/移除等待队列头

* 添加队列项到等待队列头

`void add_wait_queue(wait_queue_head_t *q, wait_queue_t *wait)`

* 移除队列项到等待队列头

`void remove_wait_queue(wait_queue_head_t *q, wait_queue_t *wait)`

* 唤醒

当设备可以使用的时候就要唤醒进入休眠态的进程，唤醒可以使用如下两个函数

`void wake_up(wait_queue_head_t *q)`   或者

`void wake_up_interruptible(wait_queue_head_t *q)`

* 等待事件

即满足某个事件(要求)后被动唤醒

## 应用程序

### 轮询

用于非阻塞IO访问。

poll、epoll 和 select 可以用于处理轮询，应用程序通过 select、epoll 或 poll 函数来查询设备是否可以操作，如果可以操作的话就从设备读取或者向设备写入数据。当应用程序调用 select、epoll 或 poll 函数的时候设备驱动程序中的 poll 函数就会执行，因此需要在设备驱动程序中编写 poll 函数

* select函数

```
int select(int nfds, 
fd_set *readfds, 
fd_set *writefds,
fd_set *exceptfds, 
struct timeval *timeout)
```

nfds: 所要监视的这三类文件描述集合中，最大文件描述符加 1

* poll函数

在单个线程中，select 函数能够监视的文件描述符数量有最大的限制，一般为 1024，可以修改内核将监视的文件描述符数量改大，但是这样会降低效率！这个时候就可以使poll 函数，**poll 函数本质上和 select 没有太大的差别**，但是 poll 函数没有最大文件描述符限制.函数原型如下

```
int poll(struct pollfd *fds, nfds_t nfds, int timeout)
```

fds: 要监视的文件描述符集合以及要监视的事件,为一个数组，数组元素都是结构体 pollfd类型的，pollfd 结构体如下所示：
```
struct pollfd {
int fd; /* 文件描述符 */
short events; /* 请求的事件 */
short revents; /* 返回的事件 */
};
```

## 阻塞试验




## 非阻塞试验


# 17 Linux异步通知

Linux 应用程序可以通过阻塞或者非阻塞这两种方式来
访问驱动设备，通过阻塞方式访问的话应用程序会处于休眠态，等待驱动设备可以使用，非阻塞方式的话会通过 poll 函数来不断的轮询，查看驱动设备文件是否可以使用。这两种方式都需要应用程序主动的去查询设备的使用情况，如果能提供一种类似中断的机制，当驱动程序可以访问的时候主动告诉应用程序那就最好了。这就是**信号**

驱动可以主要的“告诉”应用程序，即信号机制，类似于软件层面的一种中断。驱动可以通过主动向应用程序发送信号的方式来报
告自己可以访问了，应用程序获取到信号以后就可以从驱动设备中读取或者写入数据了。整个过程就相当于应用程序收到了驱动发送过来了的一个中断，然后应用程序去响应这个中断，在整个处理过程中应用程序并没有去查询驱动设备是否可以访问，一切都是由驱动设备自己告诉给应用程序的。

此外，阻塞、非阻塞、异步同知都是常用的驱动和应用程序交互的方式，没有优劣的之分，即具体问题具体分析

## 信号

异步通知的核心就是信号，在 arch/arm/include/uapi/asm/signal.h 文件中定义了 Linux 所支持的所有信号，如下所示
```
34 #define SIGHUP 1 /* 终端挂起或控制进程终止 */
35 #define SIGINT 2 /* 终端中断(Ctrl+C 组合键) */
36 #define SIGQUIT 3 /* 终端退出(Ctrl+\组合键) */
37 #define SIGILL 4 /* 非法指令 */
38 #define SIGTRAP 5 /* debug 使用，有断点指令产生 */
39 #define SIGABRT 6 /* 由 abort(3)发出的退出指令 */
40 #define SIGIOT 6 /* IOT 指令 */
41 #define SIGBUS 7 /* 总线错误 */
42 #define SIGFPE 8 /* 浮点运算错误 */
43 #define SIGKILL 9 /* 杀死、终止进程 */
44 #define SIGUSR1 10 /* 用户自定义信号 1 */
45 #define SIGSEGV 11 /* 段违例(无效的内存段) */
46 #define SIGUSR2 12 /* 用户自定义信号 2 */
47 #define SIGPIPE 13 /* 向非读管道写入数据 */
48 #define SIGALRM 14 /* 闹钟 */
49 #define SIGTERM 15 /* 软件终止 */
50 #define SIGSTKFLT 16 /* 栈异常 */
51 #define SIGCHLD 17 /* 子进程结束 */
52 #define SIGCONT 18 /* 进程继续 */
53 #define SIGSTOP 19 /* 停止进程的执行，只是暂停 */
54 #define SIGTSTP 20 /* 停止进程的运行(Ctrl+Z 组合键) */
55 #define SIGTTIN 21 /* 后台进程需要从终端读取数据 */
56 #define SIGTTOU 22 /* 后台进程需要向终端写数据 */
57 #define SIGURG 23 /* 有"紧急"数据 */
58 #define SIGXCPU 24 /* 超过 CPU 资源限制 */
59 #define SIGXFSZ 25 /* 文件大小超额 */
60 #define SIGVTALRM 26 /* 虚拟时钟信号 */
61 #define SIGPROF 27 /* 时钟信号描述 */
62 #define SIGWINCH 28 /* 窗口大小改变 */
63 #define SIGIO 29 /* 可以进行输入/输出操作 */
64 #define SIGPOLL SIGIO 
65 /* #define SIGLOS 29 */
66 #define SIGPWR 30 /* 断点重启 */
67 #define SIGSYS 31 /* 非法的系统调用 */
68 #define SIGUNUSED 31 /* 未使用信号 */
```

## 信号处理函数

这些信号就相当于中断号，不同的中断就对应不同的中断处理函数。除了SIGKILL(9)和 SIGSTOP(19)这两个信号不能被忽略外，其他的信号都可以忽略。在应用程序中使用 signal 函数来设置指定信号的处理函数，signal 函数原型如下所示
```
sighandler_t signal(int signum, sighandler_t handler)
```
**singal**:信号

**hanlder**:信号处理函数

**返回值**：设置成功的话返回信号的前一个处理函数，设置失败的话返SIG_ERR

信号处理函数的原型为
```
typedef void (*sighandler_t)(int)
```

## 驱动中对信号的处理

接下来来看看是谁在向应用程序发送信号，已经怎么发送的

### fasync_struct 结构体

结构体定义如下
```
struct fasync_struct {
	spinlock_t		fa_lock;
	int			magic;
	int			fa_fd;
	struct fasync_struct	*fa_next; /* singly linked list */
	struct file		*fa_file;
	struct rcu_head		fa_rcu;
};
```
a


驱动关闭的时候，需要释放fasync_struct申请的资源，使用` fasync_helper`， 在`file_operations` 操作集中的 `release`中实现

函数如下
```
return  xxx_fasync(-1, filp, 0);
```

### fasync函数

要让驱动端发送信号，就要在驱动端内实现fsaync函数，即在file_operations 操作集中的 fasync 函数。函数原型如下

```
int (*fasync) (int fd, struct file *filp, int on)
```

**kill_fasync 函数**
当设备可以访问的时候，驱动程序需要向应用程序发出信号，相当于产生“中断”。kill_fasync函数负责发送指定的信号，kill_fasync 函数原型如下所示：
```
void kill_fasync(struct fasync_struct **fp, int sig, int band)
```
**fp**:想要操作的fasync_struct

**sig**:信号

**band**:可读时设置为 POLL_IN，可写时设置为 POLL_OUT

**返回值**：无

## 驱动试验

试验代码： 16

在按键定时器试验程序的基础上，使用信号来主要通知应用程序自己准备好了。

### 驱动程序

当定时器到时后按键仍然有效的情况下，使用信号通知应用程序来读取驱动信息
```
/*定时器处理函数*/
static void mytimerFunction(unsigned long arg){
    int val = 0;
    struct mod_dev *dev = (struct mod_dev*)arg;
    val = gpio_get_value(dev->irq_key[0].gpio);
    if(val == 0){ /*按下*/
        //printk("key0 push\r\n");
        atomic_set(&dev->key0val , dev->irq_key[0].keyval);
    }else if(val == 1){ /*释放*/
        //printk("key0 realeas\r\n");
        atomic_set(&dev->key0val , dev->irq_key[0].keyval | 0x80); //代表释放的键值
        atomic_set(&dev->releasekey , 1);//代表释放
    }
    
    if(atomic_read(&dev->releasekey)){ /*按键释放即有效*/
        printk("kill_fasync\r\n");
        kill_fasync(&dev->fasync_queue , SIGIO , POLL_IN);//向应用发送信号
    }
}
```
程序的其他部分均不用动

### 应用程序

应用程序的信号通知主要分3个步骤，设置异步信号通知处理函数、设置当前应用程序可接受的异步通知类型，开启异步通知.程序如下
```
/*设置信号处理函数*/
static void signal_hanlder(int arg){
    int err , data;
    err = read(fd, &data , sizeof data); //读取按键值
    if(err < 0){
        /*失败*/
    }else{
        printf("sigio signal! key val = %d\r\n" ,data);
    }
}

int main(...){
	
	...
/*设置信号处理函数设置*/
    signal(SIGIO , signal_hanlder);

    /*在应用中对通知进行处理*/
    fcntl(fd , F_SETOWN , getpid()); /*设置当前进程接受SIGIO信号*/
    
    flags = fcntl(fd , F_GETFL); /*当前进程开启异步通知*/

    fcntl(fd , F_SETFL , flags | FASYNC); /*异步通知*/
while(1){
        sleep(2);
    }
	...
return 0;
}
```

以后台模式运行应用程序后，进程会休眠，等待按键按下后驱动发送异步通知来唤醒应用程序读取键值并打印

![47](.\pictures\47.png)

按下按键后

![48](.\pictures\48.png)

再次重申**阻塞、非阻塞、异步通知都是常用的进程和驱动交互的方式，没有优劣之分，具体问题具体分析**

# 18 平台驱动试验

## 驱动分离和分层

以前的试验都是简单的IO操作，但实际驱动不会像之前那样写，必须考虑**驱动的通用性**，即要求同样的驱动代码能适配不同的CPU和板子。因
此提出了**驱动的分离与分层这样的软件思路**，在这个思路下诞生了将来最常打交道的platform 设备驱动，也叫做平台设备驱动

驱动的分离和分层实际是把混杂的驱动代码进行不同的分割。传统的设备驱动分层如下所示

![41](.\pictures\41.png)

每种平台下都有一个主机驱动和设备驱动，主机驱动肯定是必须要更改的，毕竟不同的平台其 I2C 控制器不同。但是右侧的设备驱动就没必要每个平台都写一个，因为不管对于那个 SOC 来说，MPU6050 都是一样，通过 I2C 接口读写数据就行了，只需要一个 MPU6050 的驱动程序.即可。即一个设备驱动适配不同的主机驱动。

不同的主机驱动没法通用，但只要提供同一的调用API函数接口给设备驱动，这样设备驱动就不需要重写，简化了一部分代码的工作。如图所示

![42](.\pictures\42.png)

LINUX的驱动开发就要遵循上述的原则，一般主机驱动是半导体厂商写好的，我们只需要清楚API，编写好对应的设备驱动即可。

## 平台驱动模型简介

根据驱动的分离与分层，对应提出了总线、驱动和设备模型比。驱动模型就是具体的设备驱动，设备模型就是设备属性，如地址(IIC设备模型就有IIC速率、器件地址)。总线模型负责将二者结合匹配。

### 总线模型

LINUX有如 I2C、SPI、USB 等总线。但是在 SOC 中有些外设是没有总线这个概念的，但是又要使用总线、驱动和设备模型该怎么办呢？为了解决此问题，Linux 提出了 platform 这个虚拟总线，相应的就有 `platform_driver` 和 `platform_device`。**平台设备的总线工作是内核来完成的，基本不需要修改**

开发板上的总线在/sys/bus/下

![43](.\pictures\43.png)

Linux系统内核使用`bus_type `结构体表示总线，此结构体定义在文件 include/linux/device.h，bus_type 结构体内容如下
```
struct bus_type {
	const char		*name; 			/*总线名字*/
	const char		*dev_name;    
	struct device		*dev_root;
	struct device_attribute	*dev_attrs;	/* use dev_groups instead */
	const struct attribute_group **bus_groups; /*总线属性*/
	const struct attribute_group **dev_groups; /*设备属性*/
	const struct attribute_group **drv_groups;/*驱动属性*/

	int (*match)(struct device *dev, struct device_driver *drv); /*设备和驱动进行匹配*/
	int (*uevent)(struct device *dev, struct kobj_uevent_env *env);
	int (*probe)(struct device *dev);
	int (*remove)(struct device *dev);
	void (*shutdown)(struct device *dev);

	int (*online)(struct device *dev);
	int (*offline)(struct device *dev);

	int (*suspend)(struct device *dev, pm_message_t state);
	int (*resume)(struct device *dev);

	const struct dev_pm_ops *pm;

	const struct iommu_ops *iommu_ops;

	struct subsys_private *p;
	struct lock_class_key lock_key;
};
```
`match`函数：总线就是使用 match 函数来根据注册的设备来查找对应的驱动，或者根据注册的驱动来查找相应的设备，因此每一条总线都必须实现此函数.

`platform` 总线是 bus_type 的一个具体实例，定义在文件 drivers/base/platform.c，platform 总线定义如下
```
struct bus_type platform_bus_type = {
	.name		= "platform",
	.dev_groups	= platform_dev_groups,
	.match		= platform_match,
	.uevent		= platform_uevent,
	.pm		= &platform_dev_pm_ops,
};
```
向linux内核注册总线，使用`bus_resgister`，卸载一个总线就用`bus_unresgister`，但一般驱动的开发不涉及总线


### 平台驱动模型

Linux引入了驱动的分离与分层的概率，基于这个理念，又引出了总线、驱动、设备三个模型。居于这三个模型，对于有些SOC外设没有总线概念，linux给出了虚拟总线这一概念，即`platform`这一虚拟总线概念，专门用于管理没有总线模型的设备。开发板上的平台总线如图所示

![44](.\pictures\44.png)

platform平台总线当然有配套的`有 platform_driver`驱动模型和`platform_device`设备模型。它们均是在之前的平台、设备基础上进行进一步继承封装

### platform 总线

**platform 总线是 bus_type 的一个具体实例**，即platform总线数据类型也是用的`bus_type`，platform定义在文件 drivers/base/platform.c，platform 总线定义如下
```
struct bus_type platform_bus_type = {
	.name		= "platform",
	.dev_groups	= platform_dev_groups,
	.match		= platform_match,
	.uevent		= platform_uevent,
	.pm		= &platform_dev_pm_ops,
};
```

platform总线注册使用`platform_bus_init`，其调用关系如下

platform_bus_init -> bus_register 发现，platform注册进入内核，注册的内容就是上述代码区内容

前面说明了驱动和设备之间的要有个函数来进行匹配，对platform设备和驱动而言，显然是`.match		= platform_match`这个函数

### platform 驱动
`platform_driver` 结构体表示 platform 驱动，此结构体定义在文件
include/linux/platform_device.h 中，内容如下：
```
struct platform_driver {
	int (*probe)(struct platform_device *);
	int (*remove)(struct platform_device *);
	void (*shutdown)(struct platform_device *);
	int (*suspend)(struct platform_device *, pm_message_t state);
	int (*resume)(struct platform_device *);
	struct device_driver driver;
	const struct platform_device_id *id_table;
	bool prevent_deferred_probe;
};
```

**probe**函数即驱动和设备匹配成功后执行的函数，需要手动实现

**driver**:类似于platform_driver的父类，用于提供驱动模型最基础的框架。`driver`结构体主要提供了`const struct of_device_id	*of_match_table;`和`const char		*name;`配合`platform_driver`的`const struct platform_device_id *id_table;`实现设备匹配

向内核里面添加一个platform驱动需要使用`platform_driver_register(drv)`宏定义，drv就是`platform_driver`类型变量，下面来看看具体的调用过程

platform_driver_register -> __platform_driver_register(drv, THIS_MODULE) -> 存在(probe情况下）设置drv->driver.probe = platform_drv_probe; -> driver向总线添加驱动 -> device_driver->probe

即结论是：**platform驱动注册进入内核后，会和设备进行匹配，匹配成功后会执行`probe`函数的内容**

### platform 设备
platform_device 结构体定义在文件include/linux/platform_device.h 中，结构体内容如下
```
struct platform_device {
	const char	*name;
	int		id;
	bool		id_auto;
	struct device	dev;
	u32		num_resources;
	struct resource	*resource;

	const struct platform_device_id	*id_entry;
	char *driver_override; /* Driver name to force a match */

	/* MFD cell pointer */
	struct mfd_cell *mfd_cell;

	/* arch specific additions */
	struct pdev_archdata	archdata;
};
```

注意平台设备需要分无设备树和有设备树的情况，上面的结构体做了兼容

重点学习有设备树的情况

## 设备和驱动的匹配过程

驱动和设备的匹配是通过总线结构体的`.match`函数来实现的。platform总线下的`.match =platform_match`.下面来看看如何调用的,部分代码如下
```
/* Attempt an OF style match first */
	if (of_driver_match_device(dev, drv))
		return 1;

	/* Then try ACPI style match */
	if (acpi_driver_match_device(dev, drv))
		return 1;

	/* Then try to match against the id table */
	if (pdrv->id_table)
		return platform_match_id(pdrv->id_table, pdev) != NULL;
	/* fall-back to driver name match */
	return (strcmp(pdev->name, drv->name) == 0);
```

有三种匹配方式，**设备树方式、ACPI、id_table方式**，没有这个三种方式就最后比较设备和驱动结构体中的`name`验证是否驱动和设备匹配(无设备树方式下就是这个方式)

设备树下是如何验证的呢？来看看`of_driver_match_device`如何验证匹配

of_driver_match_device -> of_match_device(drv->of_match_table, dev)

即设备树下是通过验证结构体中的父类`driver`下的`const struct of_device_id	*of_match_table`来进行的匹配验证,设备树中利用`compatibale`属性来进行和`of_match_table`的匹配

of_match_device -> of_match_node(matches, dev->of_node) -> __of_match_node -> __of_device_is_compatible -> __of_find_property(device, "compatible", NULL); 验证了上面的说法。

总结一下，平台驱动方面，利用of_match_table中的`compatibale`和设备树下的`compatibale`进行字符串比较进行验证

验证成功后就会执行`probe`函数进行相应的操作

## 设备树版本驱动试验

试验代码17

分为两部分，设备树部分和平台驱动部分

### 设备树部分

使用pinctrl和gpio子系统部分的led设备树即可，无需修改。设备树中的信息如下
```
gpioled{
        compatible = "alientek,gpioled";
        status = "okay";
        pinctrl-names = "default";
        pinctrl-0 = <&pinctrl_gpioled>;
        led-gpios = <&gpio1 3 GPIO_ACTIVE_LOW>; 
        };

```

### 平台驱动部分

前面已经提到了，平台设备驱动需要关注2点

* 1 驱动和设备匹配

* 2 匹配后probe函数

针对第一点，由于是有设备树的情况，则编写`of_match_table`和设备树匹配即可。

```
struct of_device_id led_of_match[] = {
	{
		.compatible = "alientek,gpioled" , 

	},
	{/*sentinel*/},
};

/*平台驱动结构体*/
static struct platform_driver led_driver = {
    .driver		= {
		.name	= "imx6u-dts-led", /*有设备树情况*/
		.of_match_table = led_of_match, /*设备树匹配表*/
	},
	.probe		= led_probe, /*匹配成功后执行的函数*/
	.remove		= led_remove, /*卸载驱动时执行*/
};
```

此外，平台驱动的卸载就不在使用之前的在`module_exit`中的注册的函数进行卸载，在.remove函数中进行驱动卸载即可，最后平台驱动的卸载放到`module_exit`里面。

```
/*驱动的卸载放到.remove中*/
static int led_remove(struct platform_device *pdev){
  
	printk("about to remove led driver\r\n");
     //关闭LED
    gpio_set_value(gpioled.led_gpio , 1); //关闭LED
    //摧毁GPIO
    gpio_free(gpioled.led_gpio);
    //摧毁cdev
    cdev_del(&gpioled.mycdev);
    //注销字符设备
    unregister_chrdev_region(gpioled.devid , LEDDEV_CNT);
    //摧毁设备
    device_destroy(gpioled.myclass , gpioled.devid);
    //摧毁类
    class_destroy(gpioled.myclass);

	return 0;
}

static int __init leddriver_init(void){
    int ret = 0;

   //注册平台驱动
   ret = platform_driver_register(&led_driver);
   if(ret){
    printk("cant register driver\r\n");
   }

    return ret;
}

static void __exit leddriver_exit(void){
    //卸载平台
    platform_driver_unregister(&led_driver);
}

module_init(leddriver_init);
module_exit(leddriver_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("constant_z");
```

匹配成功后，设备的注册及其他的工作可以放到.probe的函数中，使其自动执行，十分的方便。

```
static int led_probe(struct platform_device *pdev){  
	int ret = 0;

	printk("led probe\r\n");
	
    printk("start to init gpioled\r\n");
    //注册字符设备驱动
    gpioled.major = 0;
    if(gpioled.major){
        gpioled.devid = MKDEV(gpioled.major , 0);
        register_chrdev_region(gpioled.devid , LEDDEV_CNT , LEDDEV_NAME);
    }
    else{ /*自动分配设备号*/
        alloc_chrdev_region(&gpioled.devid , 0 ,LEDDEV_CNT ,  LEDDEV_NAME);
    }
    gpioled.major = MAJOR(gpioled.devid);
    gpioled.minor = MINOR(gpioled.devid);
    printk("gpioled major = %d minor = %d\r\n",gpioled.major , gpioled.minor);

    //初始化字符cdev
    gpioled.mycdev.owner =  THIS_MODULE;
    cdev_init(&gpioled.mycdev , &led_fops);
    ret = cdev_add(&gpioled.mycdev , gpioled.devid , LEDDEV_CNT);
    if(ret < 0){
        printk("fail to access cdev\r\n");
    }

    //创建类
    gpioled.myclass = class_create(THIS_MODULE, LEDDEV_NAME);
    if(IS_ERR(gpioled.myclass)){
        printk("fail to create class\r\n");
        return PTR_ERR(gpioled.myclass);
    }

    //创建设备
    gpioled.mydevice = device_create(gpioled.myclass, NULL, gpioled.devid, NULL,LEDDEV_NAME);
    if(IS_ERR(gpioled.mydevice )){
        printk("fail to create device\r\n");
        return PTR_ERR(gpioled.mydevice );
    }

    //gpio相关操作
    //获取设备节点
    
	gpioled.nd = pdev->dev.of_node; //已经和设备树匹配情况下

    //获取LED所对应的gpio
    gpioled.led_gpio = of_get_named_gpio(gpioled.nd , "led-gpios" , 0);
    if(gpioled.led_gpio < 0){
        printk("fail to access property name\r\n");
        ret = -EINVAL;
        goto  fail_fnnm;
    }
    printk("led gpio num = %d\r\n",gpioled.led_gpio);
    //申请GPIO
    ret = gpio_request(gpioled.led_gpio , "gpioled.led_gpio");
    if(ret){
        printk("fail to request gpio num\r\n");
        ret = -EINVAL;
        goto fail_getnm;
    }
    //使用IO
    ret = gpio_direction_output(gpioled.led_gpio , 1);//默认高电平 不点亮
    if(ret){
        printk("fail to set gpio output\r\n");
        ret = -EINVAL;
        goto fail_stout;
    }

    gpio_set_value(gpioled.led_gpio , 0); //开启led

    return 0;

fail_stout:
    gpio_free(gpioled.led_gpio);
fail_getnm:
fail_fnnm:
//fail_fdnd:
    return ret;
}
```

老套路，没啥好讲的，其中值得注意的是设备节点已经在平台设备结构体里面了，不需要`of_find_by_path`去寻找节点了。

整体而言，平台设备驱动的编写是更加规范的，移植性也是更好的。如换设备后，只需修改对应的设备树文件，驱动部分几乎不需要更改就能驱动同一个外设



## 无设备树版本

试验代码：18

分为两部分，添加平台驱动和平台设备，并完善它们

### 平台驱动部分

驱动部分和设备树部分的驱动在于，(1)无设备树部分就意味着没有pinctrl和GPIO子系统，需要使用原始的`iomap`来操作寄存器，(2)驱动和设备的匹配方式变了，变成匹配`name`来实现驱动和设备的识别。(1)的部分之前的试验做过，不在赘述，主要看看(2)

```
/*平台驱动结构体*/
static struct platform_driver led_driver = {
    .driver		= {
		.name	= "imx6u-led", /*一定要和设备端的name相同 因为这是无设备匹配*/
	},
	.probe		= led_probe, /*匹配成功后执行的函数*/
	.remove		= led_remove, /*卸载驱动时执行*/
};



static int __init leddriver_init(void){
    int ret = 0;

   //注册平台驱动
   ret = platform_driver_register(&led_driver);
   if(ret){
    printk("cant register driver\r\n");
   }

    return ret;
}

static void __exit leddriver_exit(void){
    //卸载设备
    platform_driver_unregister(&led_driver);
}

module_init(leddriver_init);
module_exit(leddriver_exit);
```

代码几乎一摸一样，这就是Linux的兼容性。

那么gpio子系统如何代替呢。无设备树的情况下，设备和驱动匹配成功后可以使用`platform_get_resource`来获取平台设备的相关信息,该试验程序就是来获取设备中的LED寄存器信息。

```
for (i = 0; i < 5; i++) {
		ledsource[i] = platform_get_resource(pdev, IORESOURCE_MEM, i); /* 依次MEM类型资源 */
		if (!ledsource[i]) {
			dev_err(&pdev->dev, "No MEM resource for always on\n");
			return -ENXIO;
		}
		ressize[i] = resource_size(ledsource[i]);	
	}	
```

### 平台设备部分

这一部分的作用代替设备树中led节点和pinctl来实现
```
static struct resource led_resource[] = {
    {
		.start	= CCM_CCGR1_BASE, /*启动地址*/
		.end	= CCM_CCGR1_BASE + REGISTER_LENGTH - 1, /*注意要-1*/
		.flags	= IORESOURCE_MEM, /*资源类型：内存*/
	},
    {
		.start	= SW_MUX_GPIO1_IO03_BASE,
		.end	= SW_MUX_GPIO1_IO03_BASE + REGISTER_LENGTH - 1, /*注意要-1*/
		.flags	= IORESOURCE_MEM,
	},
    {
		.start	= SW_PAD_GPIO1_IO03_BASE,
		.end	= SW_PAD_GPIO1_IO03_BASE + REGISTER_LENGTH - 1, /*注意要-1*/
		.flags	= IORESOURCE_MEM,
	},
    {
		.start	= GPIO1_DR_BASE,
		.end	= GPIO1_DR_BASE + REGISTER_LENGTH - 1, /*注意要-1*/
		.flags	= IORESOURCE_MEM,
	},
    {
		.start	= GPIO1_GDIR_BASE,
		.end	= GPIO1_GDIR_BASE + REGISTER_LENGTH - 1, /*注意要-1*/
		.flags	= IORESOURCE_MEM,
	},
};

void leddevic_release(struct device *dev){
    printk("release leddevic\r\n");
}

static struct platform_device leddevic = {
	.name = "imx6u-led",/*一定要和设备中的结构name一样*/
    .id = -1,/*该设备无ID号*/
    .dev = {
        .release = &leddevic_release, /*释放平台驱动时调用的函数*/
    },
    .num_resources = ARRAY_SIZE(led_resource), /*resource数组个数*/
    .resource =  led_resource/*描述平台设备的内存资源*/
};

static int __init leddevic_init(void){
    int ret = 0;

    //注册设备
    ret = platform_device_register(&leddevic);
    if(ret){
        printk("cant register platform_device\r\n");
    }

    return ret;
}

static void __exit leddevic_exit(void){
    //卸载设备
    platform_device_unregister(&leddevic);
}

module_init(leddevic_init);
module_exit(leddevic_exit);
```
平台设备在Liunx下也要进行注册，才能和平台设备匹配，匹配后重点在`led_resource`，平台设备会利用`platform_get_resource`来读取这一信息

平台和驱动均注册进入内核后，匹配识别成功后边能通过加载试验APP来控制LED了

![46](.\pictures\46.png)

# 19 Linux自带驱动实现

Linux内部集成了很多基础性外设的驱动，著需要按照按要求修改设备树的一些内容便可以成功驱动它们

**本节更多是学习内核代码的写法，规范自身的代码规发和设计思路**

## Linux自带驱动编译

几乎全部的Linux自带驱动都可以通过menuconfig进行编译.本节对LED的配置选项如下：Device Drivers ->  LED Support (NEW_LEDS [=y]) -> LED Support for GPIO connected LEDs

配置好后，就会在根目录下的.config文件下存在对应宏定义，对应编译linux时就会编译,在\devices\ldes下的Makefile就有对应选项
```
obj-$(CONFIG_LEDS_GPIO)			+= leds-gpio.o
```
可见，对应的文件就是leds-gpio.c就是源文件.同理，知道这个源文件也可以反推是什么宏定义控制它，最后区menuconfig去搜索配置

## linux自带驱动内核源码简单分析

Linux自带的LED驱动源文件就是`leds-gpio.c`，下面看看内核源码是如何注册平台设备驱动的

### module_platform_driver
内核使用

```
module_platform_driver(gpio_led_driver);
```
完成了驱动的注册和注销，相当于
```
static int __init gpio_led_driver__init(){
	...
}
mod_init(&gpio_led_driver)
static void __exit__ gpio_led_driver__exit(){
	...
}
mod_exit(&gpio_led_driver)
```

以后可以用该`module_platform_driver`来注册平台驱动,它能节省一大段重复的代码

### 驱动匹配
```
static const struct of_device_id of_gpio_leds_match[] = {
	{ .compatible = "gpio-leds", },
	{},
};

static struct platform_driver gpio_led_driver = {
	.probe		= gpio_led_probe,
	.remove		= gpio_led_remove,
	.driver		= {
		.name	= "leds-gpio",
		.of_match_table = of_gpio_leds_match,
	},
};
```
可见没有设备树内核通过`.name	= "leds-gpio`匹配，有设备树下通过`.compatible = "gpio-leds"`来匹配

### probe函数

probe函数的内容十分简单，总结就是读取设备树的LED节点信息并存储到指定的结构体中

首先该函数做的工作是获取led在设备树中的节点信息，并存储到`gpio_leds_priv`这样一个结构体中，并且做了无设备树的情况兼容

```
struct gpio_led_platform_data *pdata = dev_get_platdata(&pdev->dev);
	struct gpio_leds_priv *priv;
	int i, ret = 0;

	if (pdata && pdata->num_leds) { /*无设备树*/
		priv = devm_kzalloc(&pdev->dev,
				sizeof_gpio_leds_priv(pdata->num_leds),
					GFP_KERNEL);
		if (!priv)
			return -ENOMEM;

		priv->num_leds = pdata->num_leds;
		for (i = 0; i < priv->num_leds; i++) {
			ret = create_gpio_led(&pdata->leds[i],
					      &priv->leds[i],
					      &pdev->dev, pdata->gpio_blink_set);
			if (ret < 0) {
				/* On failure: unwind the led creations */
				for (i = i - 1; i >= 0; i--)
					delete_gpio_led(&priv->leds[i]);
				return ret;
			}
		}
	} else { /*有设备树*/
		priv = gpio_leds_create(pdev);
		if (IS_ERR(priv))
			return PTR_ERR(priv);
	}
```

内核里的probe函数是`static int gpio_led_probe(struct platform_device *pdev)`,

## linux自带驱动的使用

### 设备树部分

首先将驱动编译进入内核，然后根据绑定文档在设备树下添加对应设备节点使平台驱动能对应匹配并执行probe函数。绑定文档在`Documentation/devicetree/bindings/leds/leds-gpio.txt`.规则原文如下
```
LED sub-node properties:
- gpios :  Should specify the LED's GPIO, see "gpios property" in
  Documentation/devicetree/bindings/gpio/gpio.txt.  Active low LEDs should be
  indicated using flags in the GPIO specifier.
- label :  (optional)
  see Documentation/devicetree/bindings/leds/common.txt
- linux,default-trigger :  (optional)
  see Documentation/devicetree/bindings/leds/common.txt
- default-state:  (optional) The initial state of the LED.  Valid
  values are "on", "off", and "keep".  If the LED is already on or off
  and the default-state property is set the to same value, then no
  glitch should be produced where the LED momentarily turns off (or
  on).  The "keep" setting will keep the LED at whatever its current
  state is, without producing a glitch.  The default is off if this
  property is not present.
- retain-state-suspended: (optional) The suspend state can be retained.Such
  as charge-led gpio.
```

总结起来就是，**一个LED子节点，有两个属性是必要的**，一个就是和平台驱动匹配的`compatible`属性，另一个就是描述具体led子节点下的pinctrl子系统的`gpios`节点信息。除外的其他信息都是可选加入的。

根据内核中要求，适配板子的设备树子节点描述如下

```
dtsled{
        compatible = "gpio-leds"; /*严格匹配*/

        led0 {
                gpios = <&gpio1 3 GPIO_ACTIVE_LOW>; /*必要项*/
                pinctrl-0 = <&pinctrl_gpioled>; /*必要项 注意检查是否有其他节点也使用*/
                label = "red";
                default-state = "on"; /*默认打开状态*/
                linux,default-trigger = "heartbeat"; /*心跳灯*/
			};
};
```

### 用户空间实现开关灯控制

设备树编译好后用挂载新的设备树后就可直接查看效果了。此外可以查看`/sys/bus/platform/devices/dtsleds`路径是否存在判断设备树是否被成功读取

在用户空间输入如下命令
```
echo 1 > /sys/class/leds/red/brightness //打开 LED0
echo 0 > /sys/class/leds/red/brightness //关闭 LED0
```

# 20 Linux杂项驱动试验

misc 的意思是混合、杂项的，因此 MISC 驱动也叫做杂项驱动，也就是当板子上的某些外设无法进行分类的时候就可以使用 MISC 驱动。MISC 驱动其实就是最简单的字符设备驱动，通常嵌套在 platform 总线驱动中，实现复杂的驱动.**使用MISC驱动能很好的节省驱动中的重复工作**

## MISC驱动

**MISC驱动时基于平台驱动下的**.所有的 MISC 设备驱动的主设备号都为 10，不同的设备使用不同的从设备号。这样做有效的缓解了字符设备驱动过多而导致的主设备号紧张的情况。

MISC 设备会自动创建 cdev，不需要像我们以前那样手动创建，因此采用 MISC 设备驱动可以简化字符设备驱动的编写


注册MISC设备余姚向内核注册一个 miscdevice 设备，miscdevice是一个结构体，内容如下

```
struct miscdevice  {
	int minor;
	const char *name;
	const struct file_operations *fops;
	struct list_head list;
	struct device *parent;
	struct device *this_device;
	const struct attribute_group **groups;
	const char *nodename;
	umode_t mode;
};
```

`minor`就是MISC的从设备号.MISC的主设备号是10确定的，从设备号可以自行定义，Liunux中预设了了一些 MISC 设备的子设备号(未使用的情况下也可以继续设置成其他)，如下所示
```
#define PSMOUSE_MINOR		1
#define MS_BUSMOUSE_MINOR	2	/* unused */
#define ATIXL_BUSMOUSE_MINOR	3	/* unused */
/*#define AMIGAMOUSE_MINOR	4	FIXME OBSOLETE */
#define ATARIMOUSE_MINOR	5	/* unused */
#define SUN_MOUSE_MINOR		6	/* unused */
#define APOLLO_MOUSE_MINOR	7	/* unused */
#define PC110PAD_MINOR		9	/* unused */
```

`name`即MISC的设备名字，注册成功后在/dev/下对应有name。`fops`也同之前的设备驱动一样

重点在于注册`miscdevice`这个变量进入内核即可。注册和卸载MISC驱动就使用
```
extern int misc_register(struct miscdevice *misc);
extern int misc_deregister(struct miscdevice *misc);
```

`misc_register`十分强大，它相当于
```
alloc_chrdev_region(); /* 申请设备号 */
cdev_init(); /* 初始化 cdev */
cdev_add(); /* 添加 cdev */
class_create(); /* 创建类 */
device_create(); /* 创建设备 */
```
返回0就是成功，其他值就是失败.下面来看看`int misc_register(struct miscdevice *misc);`这个函数

 从设备号 =255就是自动分配从设备号

## MISC驱动试验 

程序编号19

将蜂鸣器作为MISC驱动设备进行内核注册，并使用应用程序进行控制

### 设备树编写

设备树部分不需要修改，只需要使用根节点下的`beep`节点即可。同时检查下pinctl子系统是不是被其他节点共同使用.

```
alientekbeep{
                compatible = "alientek,beep";
                pinctrl-names = "default";
                pinctrl-0 = <&pinctrl_beep>;
                beep-gpios = <&gpio5 1 GPIO_ACTIVE_HIGH>;
                status = "okay";
        };
```

### 驱动编写

驱动编写大致分成平台驱动、MISC驱动编写和GPIO子系统部分

首先完成平台设备驱动的编写，设备树部分已经完成，无需关心。常规的平台设备驱动代码如下
```
/*平台驱动*/
static struct platform_driver misc_driver = 
{
    .driver = {
        .name = "beep_driver",
        .of_match_table = beep_of_match , /*设备树匹配表*/

    }, 
    .probe = miscbeep_probe , 
    .remove = miscbeep_remove,  
};

/*驱动入口函数*/
static int __init miscinit(void){
    
    return platform_driver_register(&misc_driver);/*注册平台驱动*/
}

static void __exit miscexit(void){
    platform_driver_unregister(&misc_driver); /*卸载平台驱动*/
}

module_init(miscinit);
module_exit(miscexit);
```
考虑使用`module_platform_driver(gpio_led_driver);`来进一步简化代码

匹配后，就执行`probe`函数的MISC驱动设备注册和GPIO子系统

其次是 MISC设备结构体，定义如下
```
static struct miscdevice beep_miscdev = {
    .minor  = DEV_MINOR, /*子设备号*/
    .name   = DEV_NAME,	/*驱动名称*/
    .fops   = &miscbeep_fops, /*操作函数*/
};
```
子设备号设置成255，让系统自行分配，其他部分同普通的字符设备驱动一样，无需多言

GPIO子系统部分，即申请使用蜂鸣器对应的GPIO即可。结构体如下
```
/*蜂鸣器设备结构体*/
struct miscbeep_dev{
    int gpio;
    struct device_node *nd;
}miscbeep;
```
值得注意的是，由于MISC是平台设备，所以获得设备节点就直接使用`struct platform_device`的`dev`下面的`of_node`即可。
```
miscbeep.nd = pdev->dev.of_node;
```

其他部分就是GPIO子系统常规代码，如下所示
```
  /*初始化蜂鸣器*/
    miscbeep.nd = pdev->dev.of_node; //
    miscbeep.gpio = of_get_named_gpio(miscbeep.nd , "beep-gpios" , 0);
    if(miscbeep.gpio < 0){
        printk("fail to find gpio num\r\n");
        ret = -EINVAL;
        goto fail_fdgpio;
    }
    ret = gpio_request(miscbeep.gpio , "beep-gpio");
    if(ret){
        printk("fail to request gpio %d\r\n" , miscbeep.gpio);
        ret = -EINVAL;
        goto fail_rqgpio;
    }
    ret = gpio_direction_output(miscbeep.gpio , 1);/*默认高电平*/
    if(ret < 0){
        printk("fail to set gpio\r\n");
        ret = -EINVAL;
        goto fail_stop;
    }

    return 0;


fail_stop:
    gpio_free(miscbeep.gpio);
fail_rqgpio:
fail_fdgpio:
fail_rgmisc:
    return ret;
}
```