# 第三期 LINUX系统移植
## 1系统烧写
#### 1.1 WINDOW下系统烧写
* ### 在WINDOW  S下使用NXP提供的 'mfgtool' 进行烧写。利用开发板上的USB_OTS接口链接电脑进行烧写。
**注意**:

—(1)需要将SD卡拔出并链接USB线到USB_OTG端口。

(2)波动开关到正确的启动方式 1在下2在上即可

* ### Windows下烧写的逻辑是先将LINUX的部分程序烧到DDR中，启动LINUX后再完成后续的烧写工作
* ### 后续烧写完成后，其会将文件移植到EMMC中中，而后拨版波到EMMC启动即可

步骤如下：

* 选择对应的DDR型号及其大小

![1.png](.\pictures\1.png "1.png")

* 链接USB——OTG端

* 如果成果链接会提示 "符合USB标准"的字样
![2.png](.\pictures\2.png "2.png")

* 点击烧写即可

### 1.2 使用ubantu编译脚本烧写

大致的逻辑是**在ubantu下烧写系统到SD卡中，在使用SD卡启动，启动后在LINUX中编译选择从NAND或者EMMC启动**
详细见视频教程，比较麻烦就不学习这种启动方式了
详见[https://www.bilibili.com/video/BV12E411h71h/?p=3&spm_id_from=pageDriver&vd_source=9cfe8c96e4fed1941ab35fc34dd2dde3]


## 2 uboot起步
**什么是uboot**
* uboot是一个裸机程序 ，复杂系统从单片机启动或者升级
* uboot一部分功能是bootloader，作用是启动linux或者启动系统。**最主要的工作是初始化DDR**。因为LINUXD是在DDR运行的。一般linux镜像 + 设备树（后续会说到）存放在SD、EMMC等外置存储区域。bootloader或者说uboot会引导外置存储区的linux文件下载到DDR中已启动系统。
* **uboot的主要目的就是启动linux系统**。（当然uboot可以启动其他不同系统 ， 而且linux的启动也不止uboot可以干）
* uboot是通用的bootloader工具，支持很多架构的处理。根据处理器的不同，选择不同版本的uboot在添加不同文件即可启动

### 2.2 Uboot下载
* 官网链接 [uboot下载](https://ftp.denx.de/pub/u-boot/)。缺点是适配低
* 不同的厂家会根据uboot官方下载某一版本后进行改动已适配自己的官方开发板，类似于魔改版uboot。缺点是只适配官方的开发板[NXPuboot](http://git.freescale.com/git/cgit.cgi/imx/uboot-imx.git/tag/?h=imx_v2016.03_4.1.15_2.0.0_ga&id)(注意：需要翻墙！)
* 开发板厂商又会参考厂家的uboot进行改进，并适配自己的开发板。私人定制版uboot

**后续会从NXP官方的uboot出发逐步开发出适配自己开发板的uboot**

### 2.3 预览uboot如何启动linux
下载好适配正点原子开发板的uboot后从EMMC启动开发板
![3.png](.\pictures\3.png "3.png")
图中白色区域就是uboot引导Linux进入DDR打印的相关信息。uboot的读取分两阶段
* 第一阶段 uboot会读取CPU信息、 ROM\RAM信息和输出输出串口信息后 从`开头到 Normal Boot`
* 第二阶段 uboot会引导linux内核和设备树下载到ddr中启动（从 `Normal Boot到 Starting kernel`）
* 第三阶段 uboot完成引导 linux内核自行启动

## uboot编译
* 首先将如下的两个文件移植到Ubantu下
![4.png](.\pictures\4.png "4.png")
Ubantu位置如下
![5.png](.\pictures\5.png "5.png")

执行`tar -vxjf uboot-imx-2016.03-2.1.0-g0ae7e33-v1.7.tar.bz2`语句解压
* v显示过程，x解压缩，j表示tar.bz2文件，f使用归档文件

解压后如图所示的部分文件。这就是正点原子版uboot的源码

![6.png](.\pictures\5.png "6.png")

在源码目录下执行`make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distclean`。
* 即指定架构为arm架构 ,执行交叉编译的编译器名称 , 和 make clean工程源文件

而后执行 `make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf-  mx6ull_14x14_ddr512_emmc_defconfig`
* 配置uboot，指定uboot配置为默认配置文件(正点原子修改版) ，文件名是`mx6ull_14x14_ddr512_emmc_defconfig`
成功后会生成一个.config文件，里面存储了uboot的配置
![7.png](.\pictures\7.png "5.png")
最后执行 `make V=1 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j12` 编译uboot源文件成.bin文件
* V:打印详细编译过程 j:指定12核编译
![8.png](.\pictures\8.png "8.png")
编译成功会输出以下语句和一个.bin格式的`uboot.bin`
* 可见编译后的uboot.bin会执行`./tools/mkimage -n board/freescale/mx6ullevk/imximage-ddr512.cfg.cfgtmp -T imximage -e 0x87800000 -d u-boot.bin u-boot.imx `来添加imx6ull的头部信息。和裸机编译`./imxdownload`类似

![9.png](.\pictures\9.png "9.png")

## 将生成的uboot进行文件进行OTG下载
* 找到对应的mfgtool，定义到如下目录下，将`u-boot-imx6ull-14x14-emmc.imx`文件替换成编译好的`uboot.bin`文件并命名为`u-boot-imx6ull-14x14-emmc.imx`

![10.png](.\pictures\10.png "10.png")

* 找到如下图所示的文件，将自行编译的'uboot.bin'覆盖为如下的文件名 'u-boot-imx6ull-14x14-ddr512-emmc.imx'

![11.png](.\pictures\11.png "11.png")

* 这样做的原理是，uboot在OTG模式下烧写，会使用这两个文件进行uboot下载，它会引导mfgtool文件下的linux镜像文件下载到对应的ddr中并转移到emmc中，最后从emmc启动验证


![12.png](.\pictures\12.png "12.png")
可见uboot编译的信息是正确的

* 将uboot编译的三条语句改成shell脚本，提升效率

**请注意：如果配置过uboot，就不能使用上诉的shell脚本了**直接开发，直接在`Makefile`中设置好`ARCH 和 COREE_COMPLIE`这两个变量即可。在如图所示的位置加入这两条语句即可.**以后推荐Makefile启动**

![13.png](.\pictures\13.png "13.png")


## 3 uboot命令
以后带有调试性质的开发都是从SD卡烧写。因为OTG下载慢且会烧写所有Linux文件。所有费时费力，使用SD卡更新的好处在于同裸机程序一样，编译Uboot即可，下载快启动快，不需要进入Linux系统

* 同裸机一样，清楚工程生成文件可以使用`make clean`实现

![14.png](.\pictures\14.png "14.png")

* 配置对应的DDR大小和emmc大小的uboot配置文件，同上一节`make ARCH=arm  CROSS_COMPILE=arm-linux-gnueabihf-  mx6ull_14x14_ddr512_emmc_defconfig`一致。输入 `make mx6ull_14x14_ddr512_emmc_defconfig `即可

![15.png](.\pictures\15.png "15.png")

* 最后编译`make -j16`即可生成上一节同款的uboot.bin一致


* 下载到SD卡启动IMX6ULL按下任意键进入u-boot


![16.png](.\pictures\16.png "16.png")

### help命令
* 使用输入`help`即可打印出u-boot所有的帮助命令
* 具体命令的信号 输入 `? 命令名`即可

### bdinfo
* 打印开发板的一些信息
![17.png](.\pictures\17.png "17.png")

### printfenv
* 打印出u-boot配置中的环境变量。
![18.png](.\pictures\18.png "18.png")
u-boot配置中的环境变量同makefile中的变量差不多，均是一些字符串变量，用于按照指定的配置运行u-boot所以称为环境变量。基于u-boot，可以在串口中输入并更改它们

### setnev
* 设置环境变量 
![19.png](.\pictures\19.png "19.png")
已环境变量`bootdelay`为例，其是启动u-boot后几秒后进入linux，可以设置久一点以便反馈时间。使用`setnev bootdelay 5` ,即修改5秒后进入Linux。配合下面的saveenv生效
![21.png](.\pictures\21.png "21.png")
**修改字符串形式的环境变量，内容使用单引号**
如下所示
![22.png](.\pictures\22.png "22.png")
修改后重启系统看见
![23.png](.\pictures\23.png "23.png")

* 除了修改已有的环境变量， 该命令也支持创建新的环境变量 命令同已有的u-boot命令一样
输入 `setenv author 'Constant_Z'`后保存，打印如下
![24.png](.\pictures\24.png "24.png")

* 也可以删除已有的环境变量 ，只需要赋空值即可
`setenv author `则删除了这个变量

### saveenv
* 保存环境变量 写好环境变量后，下次u-boot启动便不会执行默认的环境变量配置了。

![20.png](.\pictures\20.png "20.png")


----
**u-boot与内存相关命令介绍**
###  md命令
格式: `md[.b, .w, .l] address [# of objects]`

命令中的 [.b .w .l]对应 byte、 word和 long，也就是分别以 1个字节 、 2个字节、 4个字节
来显示内存值。 address就是要查看的内存起始地址， ，[# of objects]表示要查看的数据长度，这
个数据长度单位不是 字节，而是跟你所选择的显示格式有关。比如你设置要查看的内存长度

**注意的是uboot命令中的数字都是十六进制的！不是十进制的！**
`md.b 800000000 14`即查看0x80000000开头的0x14个字节的内容 

![25.png](.\pictures\25.png "25.png")

`md.w 800000000 14`即查看0x80000000开头的0x14个**字**的内容
![26.png](.\pictures\26.png "26.png")

`md.l 800000000 14`即查看0x80000000开头的0x14个**双字**的内容
![27.png](.\pictures\27.png "27.png")

### nm命令
nm命令用于修改指定地址的内存值，命令格式如下：

`nm [.b, .w, .l] address`

* nm命令同样可以以 .b、 .w和 .l来指定操作格式，比如现在以

`nm.b 80000000`后修改成想要的字节数据即可,后输入`q`退出

![28.png](.\pictures\28.png "28.png")

### mm命令
nm命令pro版，可以自增地址修改内存的数据。格式如下

`nm[.b.w.l] 地址`

![29.png](.\pictures\29.png "29.png")

### mw命令
推荐使用该命令修改一个内存块数据。格式如下

`mw[.b.w.l] 起始地址 修改的值 偏移地址`

![30.png](.\pictures\30.png "30.png")


### cp命令
拷贝内存区域到指定地址.格式如下

`cp[.b.l.w] 源地址 目标地址 拷贝长度`

![31.png](.\pictures\31.png "31.png")

### cmp命令
比较内存中的值是否相等。格式如下

`cmp[.b.l.w] 源地址 目标地址 长度`

![32.png](.\pictures\32.png "32.png")

---
**网络操作相关**

uboot是 支持网络的，我们在移植 uboot的时候一般都要调通网络功能，因为在移植 linux kernel的时候需要使用到 uboot的网络功能做调试。

### ping命令
* 一般情况下，初次使用该命令操作相关指令肯定会出现Ping不通问题。需要修改下虚拟机和windows下的网络配置

*在设置了ipaddr 和 ethaddr后ping虚拟机的IP时会出现下图的情况

![33.png](.\pictures\33.png "31.png")

此时，开发板、PC、和路由器的关系应该是这样的

路由器 ——————————————————————> PC ————>开发板

* 第一步：设置VM网络配置如下图所示：

![34.png](.\pictures\34.png "34.png")
这一步大致是配置VM虚拟机时桥接模式，即直接使用PC机的物理网卡。**没有VM0请关闭VM后使用管理员打开即可**

* 第二步：配置PC端的网络

仅试验过PC在无线情况下能成功，如果PC已经占用了物理网卡，那没试验过。
打开控制面板 -> 网络和Intelnet -> 高级适配器设置 -> 点击连接的WLAN属性，后选择共享给开发板连接给PC的那个有线以太网 （一般是以太网2）
![35.png](.\pictures\35.png "35.png")
这样做就是把WIFI的网络共享给了开发板，这样一来开发板就能ping通了

虚拟机的IP地址如下
![37.png](.\pictures\37.png "37.png")
ping虚拟机的IP如下就为成功

![36.png](.\pictures\36.png "36.png")

参考文献：[uboot配置](https://www.cnblogs.com/roscangjie/p/14579205.html#:~:text=1%E3%80%81%E9%A6%96%E5%85%88%E7%82%B9%E5%87%BB%E5%B7%A6%E4%B8%8A%E8%A7%92%E7%9A%84%E7%BC%96%E8%BE%91%EF%BC%8C%E9%80%89%E6%8B%A9%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%E7%BC%96%E8%BE%91%E5%99%A8%EF%BC%8C%E7%82%B9%E5%87%BB%E6%9B%B4%E6%94%B9%E8%AE%BE%E7%BD%AE%202%E3%80%81%E7%82%B9%E5%87%BB%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%EF%BC%8C%E9%80%89%E6%8B%A9%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%9A%84%E7%89%A9%E7%90%86%E7%BD%91%E5%8D%A1%EF%BC%8C%E7%84%B6%E5%90%8E%E7%A1%AE%E8%AE%A4%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%97%B6%E5%80%99%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%AF%E8%83%BD%E4%BC%9A%E8%BF%9E%E4%B8%8D%E4%B8%8A%E7%BD%91%E3%80%82,3%E3%80%81%E8%BF%9B%E5%85%A5%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91%E6%98%AF%E8%BF%9E%E6%8E%A5%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E7%9A%84%EF%BC%8C%E6%89%93%E5%BC%80%E5%AE%83%E7%9A%84%E5%B1%9E%E6%80%A7%EF%BC%8C%E9%80%89%E6%8B%A9%E5%85%B1%E4%BA%AB%EF%BC%8C%E5%8B%BE%E9%80%89%E5%B9%B6%E4%B8%94%E5%9C%A8%E5%AE%B6%E5%BA%AD%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E4%B8%AD%E9%80%89%E4%B8%AD%E4%BB%A5%E5%A4%AA%E7%BD%912%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%BF%9E%E6%8E%A5%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%89%A9%E7%90%86%E7%BD%91%E5%8D%A1%EF%BC%9B%20%E7%A1%AE%E8%AE%A4%E5%90%8E%EF%BC%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%BF%9E%E6%8E%A5%E4%B8%8A%E7%BD%91%E7%BB%9C%E4%BA%86%E3%80%82);


设置网络配置为如下图所示的
![38.png](.\pictures\38.png "38.png")
参数解释如下：
* ipaddr 开发板ip地址，可以不设置，使用 dhcp命令来从路由器获取 IP
* ethaddr 开发板的MAC地址，一定要设置。不要再同一个网络中存在相同的mac地址
* gatewayip 网关地址
* netmask 子网掩码 一般同PC上的保持一致
* serverip 服务器IP地址，也就是 Ubuntu主机 IP地址，用于调试代码。


### nfs
* 用于使用网络下载linux镜像到开发板上

nfs(Network File System)网络文件系统，通过 nfs可以在计算机之间通过网络来分享资源，比如我们将 linux 镜像和设备树文件放到 Ubuntu中，然后在 uboot中使用 nfs命令将 Ubuntu中的 linux 镜像和设备树下载到开发板的 DRAM中。这样做的目的是为了方便调试

* nfs需要提前配置，详见开发手册 第一篇的第四章 4.2节

[教程](https://blog.csdn.net/zyc3257/article/details/127054617)

### 关于nfs配置
这里面坑很多，需要重要记录以下。
* ### 在nfs之前搜先确保的事
(1)**检查网卡是否是无线有线一体**。自带电脑是有线和无线一体的。将开发板和PC用网线相连后查看网络适配器。如图所示
![39.png](.\pictures\39.png "39.png")。WLAN就是连接的WIFI，而以太网2就是开发板连接到PC的有线网卡部分。记住这个名称，后续要匹配

(2)**配置VMWARE**

**以管理员身份打开**VM，在左上方点击编辑->网络首选项。
![40.png](.\pictures\40.png "40.png")
解释以下面几个的用途
* VM1 PC和虚拟机之间相互可以访问，但虚拟机无法访问互联网
* VM8 虚拟机和PC可以互访，且虚拟机可以通过主机访问外网 。也叫NAT模式
* VM0 桥接模式。即把虚拟机在网络中是一台真正的主机，它有自己的IP地址，能自己上网。

接下来的任务就是：

（1）**VM0用来连接PC有线网卡实现开发板和PC的通信**，

（2）**其次虚拟配置到VM8，使虚拟机和PC能通信**

VM0在虚拟机上的配置如上图所示，VM8的设置如图
![41.png](.\pictures\41.png "41.png")

(3)**配置IP**
IP地址以WINDOWS下WLAN的IP为核心。输入ipconfig查看
![42.png](.\pictures\42.png "42.png")

可见WLAN的ip4是192.168.1.104.**那么接下来的目标便是，配置虚拟机的IP是192.168.1.XXX和开发板上ipaddr为192.168.1.xxx.**

（1）WINDOS端
先配置WINDOS下的以太网2，就是我们连接PC和开发版的那个网口IP，设置它为静态的IP。配置如下
![43.png](.\pictures\43.png "43.png")
接下来输入ipconfig查看。如上上图所示。如果出现两个ipv4地址，参考[windos取消自动ip获取](https://jingyan.baidu.com/article/0f5fb099a8d3692c8334eadf.html)

(2) 虚拟机端
配置好后，进入VM，先不打开虚拟机。先点击配置虚拟机。网络适配器如下
![44.png](.\pictures\44.png "44.png")
![45.png](.\pictures\45.png "45.png")

配置好后进入虚拟机。选择右上角的有线配置

![46.png](.\pictures\46.png "45.png")
en33用与VM8实现虚拟机上网，en37就是桥接到PC上的网卡。en33不管，主要配置en37

![47.png](.\pictures\47.png "47.png")
**注意：配置的静态ip地址一定不能被其他占用**

(3) 开发板端
配置开发板的ipaddr 为 192.168.1.xxx格式，如下图所示
![48.png](.\pictures\48.png "48.png")
ip地址和eth地址可随意修改，只要不被其他占用即可，随后即可实现3端ping通
![49.png](.\pictures\49.png "49.png")

* ### nfs配置
先参考开发手册第一篇第四章的nfs配置，配置好后。
一定要注意以下操作了

**如果ubantu系统是22.04.LTS,那么我们需要先降低linux内核以支持NFS2.0，参考[降低Linxu内核](http://www.openedv.com/thread-345681-1-1.html)**

降低版本后，在参看 ，打开nfs2的服务[打开nfs2.0服务](https://blog.csdn.net/Qiuoooooo/article/details/112601940#:~:text=%E5%90%8E%E9%9D%A2%E6%89%8D%E7%9F%A5%E9%81%93%EF%BC%8C%E6%96%B0%E7%89%88%E6%9C%AC%E5%8F%AA%E8%83%BD%E9%80%9A%E8%BF%87NFS%20v2%E8%AE%BF%E9%97%AE%EF%BC%8C%E8%80%8CUbuntu17%E4%BB%A5%E5%90%8E%E9%BB%98%E8%AE%A4%E5%AE%89%E8%A3%85%E7%9A%84NFS%E5%8E%BB%E6%8E%89%E4%BA%86%E5%AF%B9v2%E7%9A%84%E6%94%AF%E6%8C%81%E3%80%82%20%E6%9F%A5%E7%9C%8B%E6%94%AF%E6%8C%81%E7%9A%84NFS%E5%8D%8F%E8%AE%AE%E7%89%88%E6%9C%AC%EF%BC%9A%20cat%20%2Fproc%2Ffs%2Fnfsd%2Fversions%20%E6%88%91%E7%9A%84%E5%BE%97%E5%88%B0-2%20%2B3%20%2B4,%2B4.2%20%EF%BC%88%E8%AF%B4%E6%98%8E%E6%94%AF%E6%8C%81v3%E3%80%81v4%EF%BC%8C%E4%B8%8D%E6%94%AF%E6%8C%81v2%EF%BC%89%20%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%9A%20%E5%9C%A8%2Fetc%2Fdefault%2Fnfs-kernel-server%E6%B7%BB%E5%8A%A0RPCNFSDOPTS%3D%22--nfs-%20version%202%2C3%2C4%20--debug%20--syslog%22%EF%BC%8C%E9%87%8D%E5%90%AFNFS%E5%8D%B3%E5%8F%AF)

**最后，需要参考 ，[关闭unutu防火墙](http://www.openedv.com/forum.php?mod=viewthread&tid=345444)来关闭ubuntu的防火墙，再关闭window的防火墙就大功告成了**

![50.png](.\pictures\50.png "50.png")


### tftp命令
tftp命令同nfs作用一致，只是tftp用的tftp的协议。所以先在ubuntu下执行以下命令，安装和配置tftp服务

`sudo apt-get install tftp-hpa tftpd-hpa`

`sudo apt-get install xinetd`

之后同nfs一样，在linux目录下创建tftp传送所要的全部文件
`mkdir /home/zuozhongkai/linux/tftpboot`

**注意：这里需要给tftpboot及其子文件很大权限，否则会出错。**
![51.png](.\pictures\51.png "51.png")
所以`chmod - r 777 /home/zuozhongkai/linux/tftpboot `


### mmc 命令
用于支持修改emmc或者SD卡一些相关操作的命令
![52.png](.\pictures\52.png "52.png")


## FAT格式系统命令
对于i.mx6u来说，SD/EMMC分为3个分区，分别是:

(1)存放u-boot程序 

(2)存放Linux镜像、设备树文件 zImage .dtb格式文件 该分区是FAT格式分区

(3) 存放系统根文件，是EXT4格式

有时候需要在 uboot中对 SD卡或者 EMMC中存储的文件进行操作，这时候就要用到文件操作命令，跟文件操作相关的命令。

### fatinfo
fatinfo命令用于查询指定 MMC设备 分区的文件系统信息。

格式`fatinfo <interface> [<dev[:part]>]`


## BOOT相关操作
uboot本质就是用来启动Linux，要启动linux就必须将linux镜像和设备树放到DRAM的指定地方中去。使用boot相关命令可以做到上诉要求

### bootz
bootz命令用于启动 zImage镜像文件，格式为：

`bootz [addr [initrd[:size]] [fdt]]`

(1)addr是 Linux镜像文件在 DRAM中的位置

(2)initrd是 initrd文件在DRAM中的地址，如果不使用 initrd的话使用‘ ‘-’代替即可 

(3)fdt就是设备树文件在 DRAM中的地址。

使用bootz的前提是Linux镜像文件及设备树已经提前加载到了DRAM中(使用tftp或者nfs可以轻松做到，或者EMMC已经有这些文件，使用fatls和fatload来从开发板的ROM中加载到RAM中)，再使用bootZ启动它们
![53.png](.\pictures\53.png "53.png")

### boot
用bootz指令还要配置tftp等指令，每次加载还是比较麻烦。利用boot指令及bootcmd实现高效启动linux。

bootcmd是u-boot的一个环境变量，使用boot指令会执行bootcmd存储的指令。所以，我们只需在bootcmd存放将镜像和设备树加载到ddr中的指令和bootz指令，在利用boot指令即可快速启动linux
![54.png](.\pictures\54.png "54.png")

### run命令
配合 自定义的环境变量能实现快速启动命令。作用类似于boot指令和bootcmd的效果。只是是个性化定制款。如下图所示

自定义下载裸机程序到指定的内存，执行后便运行程序
![55.png](.\pictures\55.png "55.png")
![56.png](.\pictures\56.png "56.png")

### go命令
利用go命令，go命令用于跳到指定的地址处执行应用，命令格式如下：

`go addr`

**使用go命令配合tftp指令能很好的运行和调试裸机程序，且不在需要从SD卡启动**


## u-boot源码分析
分析u-boot源码前先编译好u-boot，因为u-boot编译后会生成一些文件，需要用到。

首先，先看看各个文件夹的大致功能
![57.png](.\pictures\57.png "57.png")

* api:提供u-boot的相关接口函数，与硬件无关
* arc:与CPU架构相关的文件，里面存放了uboot支持的CPU及其架构相关的程序文件。在编译u-boot时需要指定arc参数。
![58.png](.\pictures\58.png "58.png")
u-boot.lds就是整个uboot的链接脚本。源码根目录下的u-boot.lds是一样的

* borad:和具体官方的开发板有关的配置文件。其中，freescale的mx6系列文件是以后会用到的，需要修改成支持正点原子开发板的配置文件
![59.png](.\pictures\59.png "59.png")

* config:u-boot的默认配置文件目录，这些配置文件不同对应的平台或者开发板。其中就支持mx6ul就是支持imx6u不同开发板的。下图就是关于imx6ul在u-boot配置相关的主要文件
![60.png](.\pictures\60.png "60.png")

* fs：文件系统。u-boot支持处理的文档系统

总结以下，如下图所示
![61.png](.\pictures\61.png "61.png")
![62.png](.\pictures\62.png "62.png")

**移植u-boot最重要的文件是borad、config**

---
接下来介绍u-boot源码根目录下的一些文件

* .config : 配置文件，使用命令“ make xxx_defconfig”配置 uboot以后就会自动生成，决定整个u-boot哪些文件需要编译，哪些文件不需要编译。里面的大致代码如下：

![63.png](.\pictures\63.png "63.png")

这些配置项就是顶层或者子层makefile中的变量，所以它的配置将决定各个文件的makefile编译。一般前面没有 #号或者后续变量值为y，就在各个makefile文件中会选择编译

* .cmd 存储了一些u-boot内部需要调用的命令。如u-boot.bin.cmd文件中就是
![64.png](.\pictures\64.png "64.png")
可能某个makefile会调用u-boot.bin.cmd，就会在linux环境下执行拷贝命令

* Kconfig: 构建u-boot的可视化配置界面

* Makefile: u-boot的顶层makefile 后面会着重介绍

* README: u-boot的说明书，十分有用，不懂可以看一看

* Sytemm.map:内存映射表。开头就是中断向量表

* u-boot.x:各种u-boot生成的文件

![65.png](.\pictures\65.png "65.png")


## u-boot顶层makefile分析
源码部分过于庞大且细枝末节过多，以如何**从makefile如何到内核启动**为思想，分析顶层的makefile如何控制u-boot整个工程的编译

* 前期准备工作，由于文件太大太多，需要剔除一些不需要看的东西。使用VSCODE查看文件夹，在VSCODE中配置`setting.json`，配置如下代码屏蔽一些文献

```
{
    "search.exclude": {
        "**/node_modules": true,
        "**/bower_components": true,
        "arch/avr32":true,
        "**/*.o":true,
        "**/*.su":true,
        "**/*.cmd":true,
        "arch/arc":true,
        "arch/blackfin":true,
        "arch/m68k":true,
        "arch/microblaze":true,
        "arch/mips":true,
        "arch/nds32":true,
        "arch/nios2":true,
        "arch/openrisc":true,
        "arch/powerpc":true,
        "arch/sandbox":true,
        "arch/sh":true,
        "arch/sparc":true,
        "arch/x86":true,
        "arch/arm/mach*":true,
        "arch/arm/cpu/arm11*":true,
        "arch/arm/cpu/arm720t":true,
        "arch/arm/cpu/arm9*":true,
        "arch/arm/cpu/armv7m":true,
        "arch/arm/cpu/armv8":true,
        "arch/arm/cpu/pxa":true,
        "arch/arm/cpu/sa1100":true,
        "board/[a-e]*":true,
        "board/[g-z]*":true, 
        "board/[0-9]*":true, 
        "board/[A-Z]*":true, 
        "board/fir*":true, 
        "board/freescale/b*":true, 
        "board/freescale/l*":true, 
        "board/freescale/m5*":true, 
        "board/freescale/mp*":true, 
        "board/freescale/c29*":true,
        "board/freescale/cor*":true,
        "board/freescale/mx7*":true,
        "board/freescale/mx2*":true,
        "board/freescale/mx3*":true,
        "board/freescale/mx5*":true, 
        "board/freescale/p*":true,

        "board/freescale/q*":true,
        "board/freescale/t*":true,
        "board/freescale/v*":true,
        "board/freescale/mx6d*":true,
        "board/freescale/mx6q*":true,
        "board/freescale/mx6s*":true,
        "configs/[a-l]*":true,
        "configs/[n-z]*":true,
        "configs/[A-Z]*":true,
        "configs/M[a-z]*":true,
        "configs/M[A-Z]*":true,
        "configs/M[0-9]*":true,
        "configs/m[a-w]*":true,
        "configs/m[0-9]*":true,
        "configs/[0-9]*":true,
        "configs/mx[1-5]*":true,
        "configs/mx[7-9]*":true,
        "configs/mx6[a-t]*":true,
        "configs/mx6[v-z]*":true,
        "include/configs/[a-l]*":true,
        "include/configs/[n-z]*":true,
        "include/configs/[A-Z]*":true,
        "include/configs/m[a-w]*":true,
        "include/configs/mx[0-5]*":true,
        "include/configs/mx[7-9]*":true,
        "include/configs/mx6[a-t]*":true,
        "include/configs/mx6[v-z]*":true,
        "include/configs/[0-9]*":true,
        "include/configs/m[0-9]*":true,

    },
    "files.exclude":{
        "**/.git": true,
        "**/.svn": true,
        "**/.hg": true,
        "**/CVS": true,
        "**/.DS_Store": true,
        "arch/avr32":true,
        "**/*.o":true,
        "arch/arc":true,
        "arch/blackfin":true,
        "arch/m68k":true,
        "arch/microblaze":true,
        "arch/mips":true,
        "arch/nds32":true,
        "arch/nios2":true,
        "arch/openrisc":true,
        "arch/powerpc":true,
        "arch/sandbox":true,
        "arch/sh":true,
        "arch/sparc":true,
        "arch/x86":true,
        "arch/arm/mach*":true,
        "arch/arm/cpu/arm11*":true,
        "arch/arm/cpu/arm720t":true,
        "arch/arm/cpu/arm9*":true,
        "arch/arm/cpu/armv7m":true,
        "arch/arm/cpu/armv8":true,
        "arch/arm/cpu/pxa":true,
        "arch/arm/cpu/sa1100":true,
        "board/[a-e]*":true,
        "board/[g-z]*":true, 
        "board/[0-9]*":true, 
        "board/[A-Z]*":true, 
        "board/fir*":true, 
        "board/freescale/b*":true, 
        "board/freescale/l*":true, 
        "board/freescale/m5*":true, 
        "board/freescale/mp*":true, 
        "board/freescale/c29*":true,
        "board/freescale/cor*":true,
        "board/freescale/mx7*":true,
        "board/freescale/mx2*":true,
        "board/freescale/mx3*":true,
        "board/freescale/mx5*":true, 
        "board/freescale/p*":true,

        "board/freescale/q*":true,
        "board/freescale/t*":true,
        "board/freescale/v*":true,
        "board/freescale/mx6d*":true,
        "board/freescale/mx6q*":true,
        "board/freescale/mx6s*":true,
        "configs/[a-l]*":true,
        "configs/[n-z]*":true,
        "configs/[A-Z]*":true,
        "configs/M[a-z]*":true,
        "configs/M[A-Z]*":true,
        "configs/M[0-9]*":true,
        "configs/m[a-w]*":true,
        "configs/m[0-9]*":true,
        "configs/[0-9]*":true,
        "configs/mx[1-5]*":true,
        "configs/mx[7-9]*":true,
        "configs/mx6[a-t]*":true,
        "configs/mx6[v-z]*":true,
        "include/configs/[a-l]*":true,
        "include/configs/[n-z]*":true,
        "include/configs/[A-Z]*":true,
        "include/configs/m[a-w]*":true,
        "include/configs/mx[0-5]*":true,
        "include/configs/mx[7-9]*":true,
        "include/configs/mx6[a-t]*":true,
        "include/configs/mx6[v-z]*":true,
        "include/configs/[0-9]*":true,
        "include/configs/m[0-9]*":true,
    }

}
```

配置完过后查看VSCODE后就非常的清爽了。


### 顶层MakeFile分析
接下来，从上到下，大致分析makefile每一块在干嘛

**第一块：版本输出**
```
VERSION = 2016
PATCHLEVEL = 03
SUBLEVEL =
EXTRAVERSION =
NAME =
```
用来记录u-boot的版本相关信息

**第二块：控制makefile递归调用**
```
MAKEFLAGS += -rR --include-dir=$(CURDIR)

unexport LC_ALL
LC_COLLATE=C
LC_NUMERIC=C
export LC_COLLATE LC_NUMERIC
 
```
makefile支持递归调用，使用`$(MAKE) -C subdir`即可调用子makefile进行逐层编译。**顶层makefile想要给子makefile传递参数就使用 `export`关键字进行变量传递 `unexprt`即不传递变量到子makefile**。有两个特殊的变量：“ SHELL”和 MAKEFLAGS””，这两个变量除非使用 unexport”声明否则的话在整个 make的执行过程中，它们的值始终自动的传递给子 make。

**第三块：输出显示**
```
ifeq ("$(origin V)", "command line") #判定输入的变量是否来自终端
  KBUILD_VERBOSE = $(V)
endif
ifndef KBUILD_VERBOSE
  KBUILD_VERBOSE = 0
endif

ifeq ($(KBUILD_VERBOSE),1) # V= 1
  quiet =
  Q =
else                  #默认打印信息
  quiet=quiet_
  Q = @
endif

# V = 0时实行静默输出，不打印任何信息到终端
ifneq ($(filter 4.%,$(MAKE_VERSION)),)	# make-4 
ifneq ($(filter %s ,$(firstword x$(MAKEFLAGS))),)
  quiet=silent_
endif
else					# make-3.8x
ifneq ($(filter s% -s%,$(MAKEFLAGS)),)
  quiet=silent_
endif
endif

export quiet Q KBUILD_VERBOSE
```
即控制make的时候在终端中打印的信息，**默认是简略打印，输入`V = 1`即可打印所有编译时的信息 ， V = 0在编译的任何信息都不会打印**。


**第四块：指定编译结果存放地址**
```
ifeq ($(KBUILD_SRC),)

#是否从终端中指定了输出路径
##指定了路径
ifeq ("$(origin O)", "command line")
  KBUILD_OUTPUT := $(O)
endif
##没有指定
# That's our default target when none is given on the command line
PHONY := _all
_all:

# Cancel implicit rules on top Makefile
$(CURDIR)/Makefile Makefile: ;

ifneq ($(KBUILD_OUTPUT),)
# Invoke a second make in the output directory, passing relevant variables
# check that the output directory actually exists
saved-output := $(KBUILD_OUTPUT)
KBUILD_OUTPUT := $(shell mkdir -p $(KBUILD_OUTPUT) && cd $(KBUILD_OUTPUT) \
								&& /bin/pwd)
$(if $(KBUILD_OUTPUT),, \
     $(error failed to create output directory "$(saved-output)"))

PHONY += $(MAKECMDGOALS) sub-make

$(filter-out _all sub-make $(CURDIR)/Makefile, $(MAKECMDGOALS)) _all: sub-make
	@:

sub-make: FORCE
	$(Q)$(MAKE) -C $(KBUILD_OUTPUT) KBUILD_SRC=$(CURDIR) \
	-f $(CURDIR)/Makefile $(filter-out _all sub-make,$(MAKECMDGOALS))

# Leave processing to above invocation of make
skip-makefile := 1
endif # ifneq ($(KBUILD_OUTPUT),)
endif # ifeq ($(KBUILD_SRC),)
```
用于指定makefile文件的输出路径。**默认是存放在/common/文件下。若使用`make O=输出路径`,则会把过程文件发送到指定的输出路径下**(实际不要这么做，一般会失败，猜测有些文件指定输出到common/下且被调用)

**第五块：代码检查**
```
# Do not print "Entering directory ...",
# but we want to display it when entering to the output directory
# so that IDEs/editors are able to understand relative filenames.
MAKEFLAGS += --no-print-directory

# Call a source code checker (by default, "sparse") as part of the
# C compilation.
#
# Use 'make C=1' to enable checking of only re-compiled files.
# Use 'make C=2' to enable checking of *all* source files, regardless
# of whether they are re-compiled or not.
#
# See the file "Documentation/sparse.txt" for more details, including
# where to get the "sparse" utility.

ifeq ("$(origin C)", "command line")
  KBUILD_CHECKSRC = $(C)
endif
ifndef KBUILD_CHECKSRC
  KBUILD_CHECKSRC = 0
endif
```
uboot支持代码检查，使用命令`make C=1`使能代码检查，检查那些需要重新编译的文件。`make C=2`用于检查所有的源码文件.


**第六部分：模块编译**
```
# Use make M=dir to specify directory of external module to build
# Old syntax make ... SUBDIRS=$PWD is still supported
# Setting the environment variable KBUILD_EXTMOD take precedence
ifdef SUBDIRS
  KBUILD_EXTMOD ?= $(SUBDIRS)
endif

ifeq ("$(origin M)", "command line")
  KBUILD_EXTMOD := $(M)
endif

# If building an external module we do not care about the all: rule
# but instead _all depend on modules
PHONY += all
ifeq ($(KBUILD_EXTMOD),)
_all: all
else
_all: modules
endif

ifeq ($(KBUILD_SRC),)
        # building in the source tree
        srctree := .
else
        ifeq ($(KBUILD_SRC)/,$(dir $(CURDIR)))
                # building in a subdirectory of the source tree
                srctree := ..
        else
                srctree := $(KBUILD_SRC)
        endif
endif
objtree		:= .
src		:= $(srctree)
obj		:= $(objtree)

VPATH		:= $(srctree)$(if $(KBUILD_EXTMOD),:$(KBUILD_EXTMOD))

export srctree objtree VPATH

# Make sure CDPATH settings don't interfere
unexport CDPATH
```
u-boot支持单独编译某个模块，通过指定`make M=dir`即可。**默认情况下是编译整个代码，只有指定模块路径，才回去编译具体模块**

**Tips:分析源码不懂的，可以直接创建伪指令，把它echo出来查看!**

**第七模块：获取主机架构和系统**
```
HOSTARCH := $(shell uname -m | \
	sed -e s/i.86/x86/ \
	    -e s/sun4u/sparc64/ \
	    -e s/arm.*/arm/ \
	    -e s/sa110/arm/ \
	    -e s/ppc64/powerpc/ \
	    -e s/ppc/powerpc/ \
	    -e s/macppc/powerpc/\
	    -e s/sh.*/sh/)

HOSTOS := $(shell uname -s | tr '[:upper:]' '[:lower:]' | \
	    sed -e 's/\(cygwin\).*/cygwin/')

export	HOSTARCH HOSTOS

mytest:
	@ echo HOSTARCH = $(HOSTARCH)
	@ echo HOSTOS = $(HOSTOS)
```
u-boot在编译的时候需要知道主机的架构和系统，以此来执行相关编译。在分析中，实在不同有些变量怎么回事，利用自己的伪指令打印出来参考理解。如上述代码最后，加入自己的代码把这两个变量打印出来产看
![66.png](.\pictures\66.png "66.png")


**第八部分：设置开发板对应架构和交叉编译器**
```
# set default to nothing for native builds
ifeq ($(HOSTARCH),$(ARCH))
CROSS_COMPILE ?=
endif

# 用什么编译器，就在设置ARCH 和 CROSS_COMPILE变量 默认是空的
ARCH ?= arm
CROSS_COMPILE ?= arm-linux-gnueabihf-

KCONFIG_CONFIG	?= .config
export KCONFIG_CONFIG

#从336行开始
# Make variables (CC, etc...)

AS		= $(CROSS_COMPILE)as
# Always use GNU ld
ifneq ($(shell $(CROSS_COMPILE)ld.bfd -v 2> /dev/null),)
LD		= $(CROSS_COMPILE)ld.bfd
else
LD		= $(CROSS_COMPILE)ld
endif
CC		= $(CROSS_COMPILE)gcc
CPP		= $(CC) -E
AR		= $(CROSS_COMPILE)ar
NM		= $(CROSS_COMPILE)nm
LDR		= $(CROSS_COMPILE)ldr
STRIP		= $(CROSS_COMPILE)strip
OBJCOPY		= $(CROSS_COMPILE)objcopy
OBJDUMP		= $(CROSS_COMPILE)objdump
AWK		= awk
PERL		= perl
PYTHON		= python
DTC		= dtc
CHECK		= sparse

CHECKFLAGS     := -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ \
		  -Wbitwise -Wno-return-void -D__CHECK_ENDIAN__ $(CF)

KBUILD_CPPFLAGS := -D__KERNEL__ -D__UBOOT__

KBUILD_CFLAGS   := -Wall -Wstrict-prototypes \
		   -Wno-format-security \
		   -fno-builtin -ffreestanding
KBUILD_AFLAGS   := -D__ASSEMBLY__

# Read UBOOTRELEASE from include/config/uboot.release (if it exists)
UBOOTRELEASE = $(shell cat include/config/uboot.release 2> /dev/null)
UBOOTVERSION = $(VERSION)$(if $(PATCHLEVEL),.$(PATCHLEVEL)$(if $(SUBLEVEL),.$(SUBLEVEL)))$(EXTRAVERSION)

export VERSION PATCHLEVEL SUBLEVEL UBOOTRELEASE UBOOTVERSION
export ARCH CPU BOARD VENDOR SOC CPUDIR BOARDDIR
export CONFIG_SHELL HOSTCC HOSTCFLAGS HOSTLDFLAGS CROSS_COMPILE AS LD CC
export CPP AR NM LDR STRIP OBJCOPY OBJDUMP
export MAKE AWK PERL PYTHON
export HOSTCXX HOSTCXXFLAGS DTC CHECK CHECKFLAGS

export KBUILD_CPPFLAGS NOSTDINC_FLAGS UBOOTINCLUDE OBJCOPYFLAGS LDFLAGS
export KBUILD_CFLAGS KBUILD_AFLAGS
```
**注意：这里如果是原版u-boot，需要自行设置ARCH 和 CROSS_COMPILE变量**，后续从336行开始，再根据架构和交叉编译器，来配置一些指定的信息。重点关注`export ARCH CPU BOARD VENDOR SOC CPUDIR BOARDDIR`引出的这几个变量.打印出来如下
![67.png](.\pictures\67.png "67.png")
这几个变量不在顶层makefile文件中定义，而在uboot根目录下有个文件叫做 config.mk，这 7个变量就是在 config.mk里面定义的。config.mk中的`CONFIG_SYS_ARCH`等变量，最终又是调用根目录下的.config文件得到的。

KCONFIG_CONFIG这个变量就是指定u-boot的文件，默认是为.config文，且默认情况下.config就是xxx.config文件，添加了一些配置后，会存储到.config下，xxx.config则是默认配置。在后续的第十一部分详细介绍

**第九部分：调用scripts/Kbuild.include**
```
# We need some generic definitions (do not try to remake the file).
scripts/Kbuild.include: ;
include scripts/Kbuild.include
```
后续会用到这个文件中的一些变量

**第十部分：交叉编译工具变量配置**
```
# Make variables (CC, etc...)

AS		= $(CROSS_COMPILE)as
# Always use GNU ld
ifneq ($(shell $(CROSS_COMPILE)ld.bfd -v 2> /dev/null),)
LD		= $(CROSS_COMPILE)ld.bfd
else
LD		= $(CROSS_COMPILE)ld
endif
CC		= $(CROSS_COMPILE)gcc
CPP		= $(CC) -E
AR		= $(CROSS_COMPILE)ar
NM		= $(CROSS_COMPILE)nm
LDR		= $(CROSS_COMPILE)ldr
STRIP		= $(CROSS_COMPILE)strip
OBJCOPY		= $(CROSS_COMPILE)objcopy
OBJDUMP		= $(CROSS_COMPILE)objdump
AWK		= awk
PERL		= perl
PYTHON		= python
DTC		= dtc
CHECK		= sparse

CHECKFLAGS     := -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ \
		  -Wbitwise -Wno-return-void -D__CHECK_ENDIAN__ $(CF)

KBUILD_CPPFLAGS := -D__KERNEL__ -D__UBOOT__

KBUILD_CFLAGS   := -Wall -Wstrict-prototypes \
		   -Wno-format-security \
		   -fno-builtin -ffreestanding
KBUILD_AFLAGS   := -D__ASSEMBLY__

# Read UBOOTRELEASE from include/config/uboot.release (if it exists)
UBOOTRELEASE = $(shell cat include/config/uboot.release 2> /dev/null)
UBOOTVERSION = $(VERSION)$(if $(PATCHLEVEL),.$(PATCHLEVEL)$(if $(SUBLEVEL),.$(SUBLEVEL)))$(EXTRAVERSION)

export VERSION PATCHLEVEL SUBLEVEL UBOOTRELEASE UBOOTVERSION
export ARCH CPU BOARD VENDOR SOC CPUDIR BOARDDIR
export CONFIG_SHELL HOSTCC HOSTCFLAGS HOSTLDFLAGS CROSS_COMPILE AS LD CC
export CPP AR NM LDR STRIP OBJCOPY OBJDUMP
export MAKE AWK PERL PYTHON
export HOSTCXX HOSTCXXFLAGS DTC CHECK CHECKFLAGS

export KBUILD_CPPFLAGS NOSTDINC_FLAGS UBOOTINCLUDE OBJCOPYFLAGS LDFLAGS
export KBUILD_CFLAGS KBUILD_AFLAGS
```
大部分变量在第八部分已经定义给出，这里猜测是工程后续升级了第八部分的一些内容

**第十一部分：生成xxx.deconfig**

打开之前生成u-boot写的shell文件，代码如下
```
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distclean
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- mx6ull_14x14_ddr512_emmc_defconfig
make V=1 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j16
```

`make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distclean`执行清楚命令
```
#顶层makefile 1472行附近
distclean: mrproper
	@find $(srctree) $(RCS_FIND_IGNORE) \
		\( -name '*.orig' -o -name '*.rej' -o -name '*~' \
		-o -name '*.bak' -o -name '#*#' -o -name '.*.orig' \
		-o -name '.*.rej' -o -name '*%' -o -name 'core' \
		-o -name '*.pyc' \) \
		-type f -print | xargs rm -f
	@rm -f boards.cfg
```
执行清零工程的命令

`make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- mx6ull_14x14_ddr512_emmc_defconfig` 生成mx6ull_14x14_ddr512_emmc_defconfig默认配置文件。则接下来，寻找有%config或者%deconfig为目标的语句
```
#顶层makefile 490附近
%config: scripts_basic outputmakefile FORCE
	$(Q)$(MAKE) $(build)=scripts/kconfig $@
```
可见 生成mx6ull_14x14_ddr512_emmc_defconfig需要三个依赖 ， **scripts_basic、outputmakefile、 FORCE**

* **scripts_basic**
```
#顶层makefile 396行附近

PHONY += scripts_basic
scripts_basic:
	$(Q)$(MAKE) $(build)=scripts/basic
	$(Q)rm -f .tmp_quiet_recordmcount

scripts/basic/%: scripts_basic ;
```
`scripts_basic`直接执行`$(Q)$(MAKE) $(build)=scripts/basic`

(1)$(Q) : @  静默输出

(2)$(MAKE) : make

(3)$(build) : 它定义在Kbuile.include中
```
#Kbuile.include 179行附近
###
# Shorthand for $(Q)$(MAKE) -f scripts/Makefile.build obj=
# Usage:
# $(Q)$(MAKE) $(build)=dir
build := -f $(srctree)/scripts/Makefile.build obj
```
`build := -f $(srctree)/scripts/Makefile.build obj`在展开:`build := -f ./scripts/Makefile.build obj`

(1) srctree: .
```
#顶层makefile 203附近
ifeq ($(KBUILD_SRC),)
        # building in the source tree
        srctree := .
```
综上 ,**scripts_basic展开就是**
```
scripts_basic:
  @make -f ./scripts/Makefile.build obj=scripts/basic
```

* **outputmakefile**：
```
#顶层makefile 490附近
PHONY += outputmakefile
outputmakefile:
ifneq ($(KBUILD_SRC),)
	$(Q)ln -fsn $(srctree) source
	$(Q)$(CONFIG_SHELL) $(srctree)/scripts/mkmakefile \
	    $(srctree) $(objtree) $(VERSION) $(PATCHLEVEL)
endif
```
outputmakefile的执行首先又`KBUILD_SRC`决定，在后面把`KBUILD_SRC`用echo出来。
![68.png](.\pictures\68.png "68.png")
可见KBUILD_SRC是空的，所有outputmakefile为空，即 `outputmakefile:`

* **FORCE**:
```
#顶层makefile 1625行附近
PHONY += FORCE
FORCE:
```
可以看出 FORCE是没有规则和依赖的，所以每次都会重新生成 FORCE,则以FORCE为依赖的目标，每次都会重新生成。这样就**确保了`%config: scripts_basic outputmakefile FORCE`每次make都会重新生成

至此
```
%config: scripts_basic outputmakefile FORCE
	$(Q)$(MAKE) $(build)=scripts/kconfig $@
```
所有变量就均可以展开了
```
%config: @make -f ./scripts/Makefile.build obj=scripts/basic 
	@make -f ./scripts/Makefile.build obj=scripts/kconfig xxx.deconfig

```

接下来，就只用分析`@make -f ./scripts/Makefile.build obj=scripts/basic `和`@make -f ./scripts/Makefile.build obj=scripts/kconfig xxx.deconfig`即可

#### @make -f ./scripts/Makefile.build obj=scripts/basic
该行的指令是，执行Makefile.build来make出的文件，放到scripts/basic文件下。所以，先研究Makefile.build
```
# 前几行
# Modified for U-Boot
prefix := tpl
src := $(patsubst $(prefix)/%,%,$(obj))
ifeq ($(obj),$(src))
prefix := spl
src := $(patsubst $(prefix)/%,%,$(obj))
ifeq ($(obj),$(src))
prefix := .
endif
endif

PHONY := __build
__build:

```
主要是变量的赋值，最重要的便是`src`和`obj`，则利用__build指令打印出来
![69.png](.\pictures\69.png "69.png")

```
# The filename Kbuild has precedence over Makefile
kbuild-dir := $(if $(filter /%,$(src)),$(src),$(srctree)/$(src))
kbuild-file := $(if $(wildcard $(kbuild-dir)/Kbuild),$(kbuild-dir)/Kbuild,$(kbuild-dir)/Makefile)
include $(kbuild-file)
```
老办法，打印出来分析
![70.png](.\pictures\70.png "70.png")

最后，来看看Makefile.build的执行

```
makefile.build 116附近
__build: $(if $(KBUILD_BUILTIN),$(builtin-target) $(lib-target) $(extra-y)) \
	 $(if $(KBUILD_MODULES),$(obj-m) $(modorder-target)) \
	 $(subdir-ym) $(always)
	@:
```
为什么直接跳到116?因为回到`@make -f ./scripts/Makefile.build obj=scripts/basic`发现指定的Makefile.build没有指定由哪条语句执行make,所以一定会有一个默认的目标，那就是`__build`。即Makefile.build的make是执行__build目标下的命令

打印出来，KBUILD_BUILTIN、builtin-target、lib-target、extra-y关键变量，确定语句的执行情况
![71.png](.\pictures\71.png "71.png")
自此，build就站看成了如下指令
`__build: $(if $(KBUILD_BUILTIN),$(builtin-target) $(lib-target) $(extra-y)) \$(if $(KBUILD_MODULES),$(obj-m) $(modorder-target)) \$(subdir-ym) $(always)`就变成了`__build:scripts/basic/modules.order scripts/basic/fixdep`

先分析scripts/basic/fixdep,fixdep是一个.c文件，因此需要编译.c，在makefile.build文件中的`kbuild-file`变量会引用fixdep.c文件下的makefile来实现编译。
最终，**顶层makefile下的`scripts_basic`目标，会编译出scripts/basic/fixdep这个文件**

解决了scripts_basic后，来看如何生成xxx.deconfig的命令：
```
%config: @make -f ./scripts/Makefile.build obj=scripts/basic 
	@make -f ./scripts/Makefile.build obj=scripts/kconfig xxx.deconfig
```
前面均会用到makefile.build 只是obj不一样，xxx.deconfig的obj是scripts/kconfig ，所以，同样去分析makefile。build去看如何实现编译
同理是下面的代码
```
# Modified for U-Boot
prefix := tpl
src := $(patsubst $(prefix)/%,%,$(obj))
ifeq ($(obj),$(src))
prefix := spl
src := $(patsubst $(prefix)/%,%,$(obj))
ifeq ($(obj),$(src))
prefix := .
endif
endif

PHONY := __build
__build:
```
这次变量就变为了

src= scripts/kconfig 

kbuild-dir = ./scripts/kconfig 

kbuild-file = ./scripts/kconfig/Makefile 

include = ./scripts/kconfig/Makefile

打开./scripts/kconfig/Makefile查看有无相关生成obj信息
```
# ./scripts/kconfig/Makefile 113行
%_defconfig: $(obj)/conf
	$(Q)$< $(silent) --defconfig=arch/$(SRCARCH)/configs/$@ $(Kconfig)
```
可见，这行目标相关生成xxx_.deconfig，依赖是scripts/kconfig/conf  同理，需要各个变量的具体信息来展开
* Q : @
* $< : 依赖文件的集合
* $(silent)：静默编译，即不显示具体编译情况
* SRCARCH : ..
* kconfig ： Kconfig

![72.png](.\pictures\72.png "72.png")
所以展开便是`@ $(obj)/conf --defconfig=arch/../configs/%_defconfig $(Kconfig)`

同scripts_basic大致一样,xxx.deconfig目标是生成scripts/kconfig/conf 一些文件

至此，生成xxx.deconfig文件就介绍完了，总结一下如下图
![73.png](.\pictures\73.png "73.png")



### make执行过程
上面介绍了配置u-boot的相关内容，配置好以后就可以执行make编译了，在make中除了指定arch 和 csrosscomplie以外没有指定目标，所以是使用默认目标。
```
# 顶层makefile 129
PHONY := _all
_all:

#顶层makefile 194
# If building an external module we do not care about the all: rule
# but instead _all depend on modules
PHONY += all
ifeq ($(KBUILD_EXTMOD),)
_all: all
else
_all: modules
endif
```
这两段指令，就指定了默认目标是 all 。 all目标的具体内容如下：
```
#顶层makefile第819行
all:		$(ALL-y)
ifneq ($(CONFIG_SYS_GENERIC_BOARD),y)
	@echo "===================== WARNING ======================"
	@echo "Please convert this board to generic board."
	@echo "Otherwise it will be removed by the end of 2014."
	@echo "See doc/README.generic-board for further information"
	@echo "===================================================="
endif
ifeq ($(CONFIG_DM_I2C_COMPAT),y)
	@echo "===================== WARNING ======================"
	@echo "This board uses CONFIG_DM_I2C_COMPAT. Please remove"
	@echo "(possibly in a subsequent patch in your series)"
	@echo "before sending patches to the mailing list."
	@echo "===================================================="
endif
```
上诉可知 all这个目标，依赖于`ALL_y`，而目标`ALL_y`有如下语句
```
#顶层makefile 474
# Always append ALL so that arch config.mk's can add custom ones
ALL-y += u-boot.srec u-boot.bin u-boot.sym System.map u-boot.cfg binary_size_check

#顶层makefile 779
# enable combined SPL/u-boot/dtb rules for tegra
ifeq ($(CONFIG_TEGRA)$(CONFIG_SPL),yy)
ALL-y += u-boot-tegra.bin u-boot-nodtb-tegra.bin
ALL-$(CONFIG_OF_SEPARATE) += u-boot-dtb-tegra.bin
endif

#顶层makefile 785
# Add optional build target if defined in board/cpu/soc headers
ifneq ($(CONFIG_BUILD_TARGET),)
ALL-y += $(CONFIG_BUILD_TARGET:"%"=%)
endif
```
可见，All_y目标必定会依赖于u-boot.srec u-boot.bin u-boot.sym System.map u-boot.cfg binary_size_check这几个文件，而后会通过上节的config文件，选择性的编译其他文件的编译。
![74.png](.\pictures\74.png "74.png")
如图，一些没有注释掉的语句就是控制u-boot是否编译对应一些.c文件的配置

All_y最重要的就是u-boot.bin 有关u-boot.bin的配置如下
```
#顶层makefile 842
ifeq ($(CONFIG_OF_SEPARATE),y)
u-boot-dtb.bin: u-boot-nodtb.bin dts/dt.dtb FORCE
	$(call if_changed,cat)

u-boot.bin: u-boot-dtb.bin FORCE
	$(call if_changed,copy)
else
u-boot.bin: u-boot-nodtb.bin FORCE
	$(call if_changed,copy)
endif
```
首先判断变量`CONFIG_OF_SEPARATE`是否是y,一般这类变量存放在config文件中，如果没有，先make u-boot,再终端中全局搜索一下`grep -nR "CONFIG_OF_SEPARATE"`
![75.png](.\pictures\75.png "75.png")
发现没有给CONFIG_OF_SEPARATE赋值为y的语句，所以执行
```
else
u-boot.bin: u-boot-nodtb.bin FORCE
	$(call if_changed,copy)
endif
```

可见u-boot.bin又依赖于 u-boot-nodtb.bin。查看u-boot-nodtb.bin的依赖项。
```
#顶层makefile 883
u-boot-nodtb.bin: u-boot FORCE
	$(call if_changed,objcopy)
	$(call DO_STATIC_RELA,$<,$@,$(CONFIG_SYS_TEXT_BASE))
	$(BOARD_SIZE_CHECK)
````
发现u-boot-nodtb.bin又依赖于 u-boot。又去查看u-boot依赖项
```
# 顶层makefile 1187
u-boot:	$(u-boot-init) $(u-boot-main) u-boot.lds FORCE
	$(call if_changed,u-boot__)
```
再接下俩，就是找到u-boot-init、u-boot-main 
u-boot.lds依赖项

* u-boot-init 、u-boot-main  依赖项

```
#顶层makefile 695
u-boot-init := $(head-y)
u-boot-main := $(libs-y)
```
u-boot-init的依赖项head-y不在顶层makefile定义，而在关于cpu架构的文件中定义

![76.png](.\pictures\76.png "76.png")
使用的cpu架构是arm,所以执行的应该是红框的变量。`$(CPU)`变量由前面可知是`armv7`,所以`head-y := arch/arm/cpu/armv7/start.o`

`u-boot-main`依赖项`libs-y`如下：
```
# 顶层makefile 637
libs-y += lib/
libs-$(HAVE_VENDOR_COMMON_LIB) += board/$(VENDOR)/common/
libs-$(CONFIG_OF_EMBED) += dts/
libs-y += fs/
libs-y += net/
libs-y += disk/
libs-y += drivers/
libs-y += drivers/dma/
libs-y += drivers/gpio/
libs-y += drivers/i2c/
libs-y += drivers/mmc/
libs-y += drivers/mtd/
.
.
.
libs-y		:= $(patsubst %/, %/built-in.o, $(libs-y))
```
由此可见 libs-y存放了外设及一些其他程序源码的目录，并在最后这里调用了函数 patsubst，将 libs-y中的"/"替换为 "/built-in.o"，比如 "drivers/dma/"就变为了"drivers/dma/built-in.o"，”，相当于将 libs-y改为所有子目录中 built-in.o文件的集合。那么

u-boot.lds是链接文件，所以综上,**u-boot目标干的事情就是这个规则就相当于将以 u-boot.lds为链接脚本，将 arch/arm/cpu/armv7/start.o和各个子目录下的 built-in.o链接在一起生成 u-boot。**

链接比较关心的是链接代码段的起始地址，根据开发板不同，链接的首地址不同。正点原子的代码段起始地址应该是0x87800000,具体在哪里设置的呢？首先看u-boot.lds

![77.png](.\pictures\77.png "77.png")
可见不在顶层的链接文件中指定，使用`grep`来整体查看
![78.png](.\pictures\78.png "78.png").可见实在红框处定义得到，并且能成功写入链接脚本

最终，总结make的流程如下图
![79.png](.\pictures\79.png "79.png")

## u-boot启动流程
u-boot启动流程提到外设如何通过u-boot初始化，并了解一下u-boot如何引导进入Linux内核

### u-boot.lds详解
**u-bootl.lds只有进过编译才能使用生成**  `ENTRY(_start)`便是启动u-boot的入口地址，_start在vector.S中定义。
![80.png](.\pictures\80.png "80.png")
可见这个文件就类似于之前裸机中的start.s，存放了arm系列的中断向量表等启动配置

回到.lds。后续是
```
OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
OUTPUT_ARCH(arm)
ENTRY(_start)
SECTIONS
{
 . = 0x00000000;
 . = ALIGN(4);
 .text :
 {
  *(.__image_copy_start)
  *(.vectors)
  arch/arm/cpu/armv7/start.o (.text*)
  *(.text*)
 }
 .
 .
 .
}
```
在上一届提到，起始地址会被重新设置到0x87800000。后面进入.text部分，会首先进入.__image_copy_start,




### relocate_code详解
relocate_code的主要工作是将原来在0x87800000的u-boot代码迁移至上一节提到的gd->relocaddr开始的新的地方

该函数主要分为两部分，(1)拷贝整个代码 (2)对全局变量和静态变量进行迁移

* **拷贝代码**
```
ENTRY(relocate_code)
	ldr	r1, =__image_copy_start	/* r1 <- SRC &__image_copy_start 获取景象地址 = 0x87800000*/
	subs	r4, r0, r1		/* r4 <- relocation offset 新地址到原地址的偏移 9ff47000-87800000 = 0x18747000*/
	beq	relocate_done		/* if r0 == r1 then skip relocation */
	ldr	r2, =__image_copy_end	/* r2 <- SRC &__image_copy_end  r2是u-boot最后的地址 */

/*拷贝整个u-boot从878000 -> r0中的新地址*/
copy_loop:
	ldmia	r1!, {r10-r11}		/* copy from source address [r1]    */
	stmia	r0!, {r10-r11}		/* copy to   target address [r0]    */
	cmp	r1, r2			/* until source end address [r2]    */
	blo	copy_loop
```

* **变量迁移**
为了解决如全局变量或者其他情况下，链接地址和运行地址在拷贝后不一致的情况。如下代码段所示
```
/*测试u-boot位置无关码代码*/
static int rel_a = 0;

void rel_test(void){
	rel_a = 100;
	printf("\r\nrel_a = %d\r\n", rel_a);
}

int board_init(void)
{
	rel_test();
```
将其反汇编出来
```
<代码运行部分>
878037ec <rel_test>:
878037ec:	e59f300c 	ldr	r3, [pc, #12]	; 87803800 <rel_test+0x14>
878037f0:	e3a01064 	mov	r1, #100	; 0x64
878037f4:	e59f0008 	ldr	r0, [pc, #8]	; 87803804 <rel_test+0x18>
878037f8:	e5831000 	str	r1, [r3]
878037fc:	ea00d1d4 	b	87837f54 <printf>
87803800:	8784f1e0 	strhi	pc, [r4, r0, ror #3]
87803804:	8784070f 	strhi	r0, [r4, pc, lsl #14]

87803808 <board_init>:
87803808:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
8780380c:	e3a06007 	mov	r6, #7
87803810:	ebfffff5 	bl	878037ec <rel_test>

<静态全局变量存放处>
8784f1e0 <rel_a>:
8784f1e0:	00000000 	andeq	r0, r0, r0
```
878037ec : ldr	r3, [pc, #12]	;即pc = 878037ec + 8 + 12 = 0x87803800  r3 存放0x87803800 


878037f0:	e3a01064 	mov	r1, #100	; 0x64 r1存放 0x64 对应代码中 rel_a += 100;




## u-boot 启动linux内核
uboot启动linux内核使用bootz命令。主要关注bootz如何运行， u-boot如何完成使命退出 ， Linux如何启动，三部分

### bootz命令运行
* **(1) images全局变量**

image全局变量是bootm_headers结构体变量，bootm_headers大致结构如下
```
typedef struct bootm_headers {
	/*
	 * Legacy os image header, if it is a multi component image
	 * then boot_get_ramdisk() and get_fdt() will attempt to get
	 * data from second and third component accordingly.
	 */
	image_header_t	*legacy_hdr_os;		/* image header pointer */
	image_header_t	legacy_hdr_os_copy;	/* header copy */
	ulong		legacy_hdr_valid;
  .
  .
  .
 #ifndef USE_HOSTCC
	image_info_t	os;		/*OS镜像信息*/
	ulong		ep;		/* OS入口地址 对6u来说就是0x08080000*/

	ulong		rd_start, rd_end;/* ramdisk start/end */

	char		*ft_addr;	/* 设备树地址 */
	ulong		ft_len;		/* 设备树长度 */

	ulong		initrd_start; 
	ulong		initrd_end;
	ulong		cmdline_start;
	ulong		cmdline_end;
	bd_t		*kbd;
#endif

	int		verify;		/* getenv("verify")[0] != 'n' */

/*启动阶段的宏定义，用于控制linux启动*/
#define	BOOTM_STATE_START	(0x00000001)
#define	BOOTM_STATE_FINDOS	(0x00000002)
#define	BOOTM_STATE_FINDOTHER	(0x00000004)
#define	BOOTM_STATE_LOADOS	(0x00000008)
#define	BOOTM_STATE_RAMDISK	(0x00000010)
#define	BOOTM_STATE_FDT		(0x00000020)
#define	BOOTM_STATE_OS_CMDLINE	(0x00000040)
#define	BOOTM_STATE_OS_BD_T	(0x00000080)
#define	BOOTM_STATE_OS_PREP	(0x00000100)
#define	BOOTM_STATE_OS_FAKE_GO	(0x00000200)	/* 'Almost' run the OS */
#define	BOOTM_STATE_OS_GO	(0x00000400)
	int		state;

#ifdef CONFIG_LMB
	struct lmb	lmb;		/* for memory mgmt */
#endif
} bootm_headers_t;
```
bootm_headers_t主要分为三部分，linux镜像的信息、linux设备树信息、linux启动阶段宏

image_info_t 结构体存储了linux镜像的一些信息，如下
```
typedef struct image_info {
	ulong		start, end;		/* start/end of blob */
	ulong		image_start, image_len; /* 内核起始点、内核长度 */
	ulong		load;			/*LINUX内核从ddr哪里开始 */
	uint8_t		comp, type, os;		/*zImage文件时压缩文件，因此这里是关于压缩的一些信息  */
	uint8_t		arch;			/*CPU架构 */
} image_info_t;
```

对照地址，分别下载系统镜像和设备树
![83](.\pictures\83.png "83.png")
在使用命令`bootz 80800000 - 83000000`启动linux镜像.


bootz命令的执行依赖于do_bootz这一函数
```
int do_bootz(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	int ret;

	/* Consume 'bootz' */
	argc--; argv++;

	if (bootz_start(cmdtp, flag, argc, argv, &images))
		return 1;

	/*
	 * We are doing the BOOTM_STATE_LOADOS state ourselves, so must
	 * disable interrupts ourselves
	 */
	bootm_disable_interrupts();

	images.os.os = IH_OS_LINUX;
	ret = do_bootm_states(cmdtp, flag, argc, argv,
			      BOOTM_STATE_OS_PREP | BOOTM_STATE_OS_FAKE_GO |
			      BOOTM_STATE_OS_GO,
			      &images, 1);

	return ret;
}
```

**do_bootz的调用关系**

do_bootz  
&emsp;->bootz_start 

&emsp; &emsp; &emsp;->do_bootm_states 不同阶段执行不同函数

&emsp; &emsp; &emsp;&emsp;->bootm_start 由BOOTM_STATE_START决定(全局变量处有详细定义))

&emsp; &emsp; &emsp;&emsp; &emsp;->全局变量image清零

&emsp; &emsp; &emsp;&emsp; &emsp; ->设置
image.state = 由BOOTM_STATE_START

&emsp; &emsp; &emsp;设置zImage的入口地址

&emsp; &emsp; &emsp;->bootz_setup

&emsp; &emsp; &emsp; &emsp;配置zimage_header结构体

&emsp; &emsp; &emsp;->lmb_reserve

&emsp; &emsp; &emsp;->bootm_find_images

&emsp; &emsp; &emsp;&emsp;->boot_get_fdt /*找到设配树 并将设备树的起始地址写入对应的image全局变量*/

&emsp;->bootm_disable_interrupts /*关闭中断*/

&emsp;**images.os.os = IH_OS_LINUX;/*设置了当前要启动的镜像是linux镜像*/**

&emsp;->do_bootm_states

&emsp; &emsp; &emsp;->bootm_os_get_boot_func/*查找linux内核启动函数*/

&emsp; &emsp; &emsp; &emsp;->do_bootm_linux/*linux内核启动函数*/

&emsp; &emsp; &emsp;boot_fn = boot_os[os]

&emsp; &emsp; &emsp;->BOOTM_STATE_OS_PREP控制的boot_fn = do_bootm_linux

&emsp; &emsp; &emsp;&emsp;->boot_prep_linux(images);/*主要用于处理环境变量bootargs,bootargs保存着传递给linux内核的参数


&emsp; &emsp; &emsp;->由BOOTM_STATE_OS_GO控制，执boot_selected_os

&emsp; &emsp; &emsp;&emsp;->boot_fn = do_bootm_linux

&emsp; &emsp; &emsp;&emsp;&emsp;->boot_jump_linux

&emsp; &emsp; &emsp;&emsp;&emsp;&emsp;获取机器id

&emsp; &emsp; &emsp;&emsp;&emsp;&emsp;设置kernel_entry函数的地址为80800000

&emsp; &emsp; &emsp;&emsp;&emsp;&emsp;->announce_and_cleanup /*输出一系列的kernel内核信息*/

&emsp; &emsp; &emsp;&emsp;&emsp;&emsp;配置设备树的地址

&emsp; &emsp; &emsp;&emsp;&emsp;&emsp;->kernel_entry /*u-boot完成引导任务，接下来启动linux内核*/



**bootz的执行流程**
![85](.\pictures\85.png)



---
**补充：**

zimage_header结构体如下
```
struct zimage_header { /*zImage文件的头部信息*/
	uint32_t	code[9];
	uint32_t	zi_magic; //应该为0x016f2818 linux内核用的zImage 标号便是0x016f2818 
	uint32_t	zi_start;
	uint32_t	zi_end;
};
```
如何证明zi_magic确实用的是0x016f2818，通过`zi = (struct zimage_header *)map_sysmem(image, 0);/*取出zImage中信息zi_magic信息*/`
这行代码我们知道，zi取自image,image又是zImage的起始地址，根据zimage_header结构体计算，它的第4 * 9 = 36，即第36个字节开始的4字节应该是zi_magic。查看zImage数据
![84.png](.\pictures\84.png)
所以zi_magic就是这个版本号0x016f2818


                    



## u-boot移植
### u-boot官方移植测试
重点学习如何基于NXP官方的 uboot移植到正点原子的 I.MX6ULL开发板上，学习如何在 uboot中添加我们自己的板子。以此了解u-boot的启动过程

* 如何下载NXP官方的u-boot程序

[NXP官方u-boot](https://source.codeaurora.org/external/imx/uboot-imx)

* 移植官方u-boot并重命名

![86.png](.\pictures\86.png)

* NXP官方u-boot配置在u-boot下的config文件中，名字为**mx6ull_14x14_evk_emmc_defconfig**,以后会参考

* 主要参考的重点是**DDR /DRAM 、串口、SD卡、EMMC**，这些事开发板的基础部分。这些部分的代码**基本上和官方的一样**

* 编译下载nxp官方u-boot的测试结果

&emsp;&emsp;&emsp; 串口、SD卡、EMMC测试成功

&emsp;&emsp;&emsp; LCD、NET失败


**注意：如果之前SD卡烧写过u-boot，其里面的环境变量不会被覆盖掉，此时需要格式化SD卡**

---
### u-boot移植适配正点原子开发板

**1.添加开发板配置文件**

在NXP官方的默认配置问价文件的基础上，修改成自己开发板的文件，NXP的配置文件是`mx6ull_14x14_evk_emmc_defconfig`，在根目录下的config文件中。复制成`mx6ull_alientek_defconfig`在这个文件上进行修改，并修改shell脚本中的修改 **注意修改的结尾部分一定要以defconfig结尾**

```
CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ullevk/imximage.cfg,MX6ULL_EVK_EMMC_REWORK"
CONFIG_ARM=y
CONFIG_ARCH_MX6=y
CONFIG_TARGET_MX6ULL_14X14_EVK=y
CONFIG_CMD_GPIO=y
```

其中，`CONFIG_SYS_EXTRA_OPTIONS`规定下.cfg文件便是将u-boot.bin打包成u-boot.imx。因此，自己的开发板要有自己的文件夹，以支持自己的板子。之后会在对应的文件夹下添加对应的文件

第4行的`CONFIG_TARGET_MX6ULL_14X14_EVK=y`修改目标名称变成`CONFIG_TARGET_MX6ULL_ALIENTEK_EMMC=y`.因此，我们的mx6ull_alientek_defconfig如下
```
CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ull_alientek_emmc/imximage.cfg,MX6ULL_EVK_EMMC_REWORK"
CONFIG_ARM=y
CONFIG_ARCH_MX6=y
CONFIG_TARGET_MX6ULL_ALIENTEK_EMMC=y
CONFIG_CMD_GPIO=y
```

**2.添加头文件**

不同的板子，对一些板子的配置信息一般存放在一个头文件中。NXP官方的6u的配置信息存放在`include/configs/mx6ullevk.h下`.因此，我们自己要拷贝一份用以修改成正点原子支持的开发板。.h文件的之后会讲，现在先熟悉移植的整体流程。把它复制成 `mx6ull_alientek_emmc.h`并修改.h文件中的条件编译

**3.添加板子对应的板级文件**

u-boot规定每个开发板要给出其对应的板级文件，以启动对应开发板的外设。存放在`borads/freescalse/mx6ulevk/ `，因此，我们还需要拷贝自己的板级文件适配正点原子官方的板子，就存放在`borads/freescalse/mx6ull_alientek_emmc/`文件下。接下来，需要以此修改一些文件的配置

* 修改Konfig
修改成如下的配置
```
if TARGET_MX6ULL_ALIENTEK_EMMC //->对应 mx6ull_alientek_emmc.defconfig的第4行

config SYS_BOARD
	default "mx6ull_alientek_emmc" //->对应borads/freescalse/mx6ull_alientek_emmc

config SYS_VENDOR
	default "freescale"

config SYS_CONFIG_NAME
	default "mx6ull_alientek_emmc"//对应borads/freescalse/mx6ull_alientek_emmc

endif
```

* 修改MAAINTAINERS
```
MX6ULLEVK BOARD
M:	Peng Fan <peng.fan@nxp.com>
S:	Maintained
F:	board/freescale/mx6ull_alientek_emmc/ //->对borads/freescalse/mx6ull_alientek_emmc应
F:	include/configs/mx6ull_alientek_emmc.h//->borads/freescalse/mx6ull_alientek_emmc
F:	configs/mx6ull_alientek_defconfig//->对应defconfig
```

* 修改makefile 
```
# (C) Copyright 2015 Freescale Semiconductor, Inc.
#
# SPDX-License-Identifier:	GPL-2.0+
#

obj-y  := mx6ull_alientek_emmc.o #->对应deconfig

extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
$(obj)/plugin.bin: $(obj)/plugin.o
	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
```

*修改imximage.cfg
```
# 32行附近
 #ifdef CONFIG_USE_PLUGIN
/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
PLUGIN	board/freescale/mx6ull_alientek_emmc/plugin.bin 0x00907000 ->对应指定的文件夹
```


* **4.修改u-boot图形配置界面**
定位到/arch/arm/cpu/armv7/mx6下文件夹

* 修改Konfig
```
# 208行附近 模仿上面的TARGET_MX6ULL_9X9_EVK代码修改成如下形式
config TARGET_MX6ULL_ALIENTEK_EMMC
	bool "Support mx6ull_alientek_emmc"
	select MX6ULL
	select DM
	select DM_THERMAL
  .
  .
  .
# 文本最后添加上
source "board/freescale/mx6ull_alientek_emmc/Kconfig"
```
* **下载验证**

移植完后启动shell脚本，修改至没有错误后下载验证。成功启动u-boot即为成功

![86](.\pictures\87.png)


以上就是整体的u-boot移植修改过程，接下来，需要对各个部分进行修改以适配自己的板子


---

## u-boot LCD驱动修改

LCD的驱动经过上一届介绍，应该在板级文件下修改，就**修改/borads/freesscale/下的mx6ull_alientek_emmc.c 和 mx6ull_alientek_emmc.h**

主要做的工作有两件事
* 1.适配对应GPIO
* 2.修改LCD参数

### 设配GPIO
```
# mxu6ull_alientek_emmc 727行附近
#ifndef CONFIG_VIDEO_MXS  //记得修改回去成ifdef!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
static iomux_v3_cfg_t const lcd_pads[] = { /*正点原子开发版IO的管脚适配这段代码*/
	MX6_PAD_LCD_CLK__LCDIF_CLK | MUX_PAD_CTRL(LCD_PAD_CTRL),
	MX6_PAD_LCD_ENABLE__LCDIF_ENABLE | MUX_PAD_CTRL(LCD_PAD_CTRL),
	MX6_PAD_LCD_HSYNC__LCDIF_HSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
  .
  .
  .
}
```
正点原子开发板的管教均设配该程序的LCD管教，因此不需要改动，如果不一样，要按照规定改动。


### 修改LCD参数
mx6ull_alientek_emmc.c中找到如下语句
```
# mu6ull_alientek_emmc.c 781行附近
/*LCD参数结构体*/
struct display_info_t const displays[] = {{
	.bus = MX6UL_LCDIF1_BASE_ADDR, /*LCDIF_RL寄存器 即ELCD寄存器的首地址*/
	.addr = 0,
	.pixfmt = 24,/*一个像素多少位 RGB888 就是24位*/
	.detect = NULL,
	.enable	= do_enable_parallel_lcd,
	.mode	= { /*LCD屏幕参数结构体 需要按照LCD的参数进行修改*/
		.name			= "ALIENTEK_1024X600",
		.xres           = 1024, /*宽度可显示的范围*/
		.yres           = 600,/*高度可显示的范围*/
		.pixclock       = 19531, /*计算公式 1/像素时钟 * 10^12 单位从皮秒换算到秒 屏幕像素时钟是51.2Mhz*/
		.left_margin    = 140, /*HBPD*/
		.right_margin   = 160, /*HFPD*/
		.upper_margin   = 20, /*VBPD*/
		.lower_margin   = 12, /*VFBD*/
		.hsync_len      = 20, /*HSPW*/
		.vsync_len      = 3, /*VSPW*/
		.sync           = 0,
		.vmode          = FB_VMODE_NONINTERLACED
} } };
```
display_info_t 就是存放LCD具体参数的结构体，其中参数的大致信息在上方已经注释

**还需要注意的一点是 修改的结构成员变量`name`后，需要对应到mu6ull_alientek_emmc.h中，修改参数`pannel`，使其和name的值一致，才能顺利启动LCD**

修改好过后，编译下载后，即可成功点亮，并在LCD上有NXP的logo


## 配置网络
### IMX6U网络通信方案
I.MX6UL/ULL内部有个以太网 MAC外设，也就是 ENET，需要外接一个 PHY芯片来实
现网络通信功能，也就是内部 MAC+外部 PHY芯片的方案。

即IMX6U可以通过插网线 + PHY芯片来实现网络通信。在IMX6ULL参考手册cp22有详细的介绍ENET

正点原子官方的外部PHY芯片上LAN8720A芯片，与官方的PHY芯片不同，因此需要修改对应的驱动程序。

那么内部的ENET和外部的LAN8720如何实现物理的链接呢？参看电路图
![88](.\pictures\88.png)

---
LAN8720介绍

* IMX6U有一个管理接口MDIO来管理PHY芯片，有两根线，MDIO和MDC，一个MDIO接口可以管理32个外部PHY芯片.**MDIO通过PHY ADDR即PHY的地址来确定访问哪块PHY芯片，ENTI1，即网口1的PHY芯片是0X0,ENTI2的PHY地址是0X1**

* LAN8720的第10管教PHYAD0决定PHY的地址，如图是0，所以ENT1外界的PHY芯片地址就是0x0

* LAN8720的TXD0 ...就是与ENT1传输数据的接口

* 每个LAN8720都有复位管教，ENET1的是SNVS_TAMPER7 ,ENET2是SNVS_TAMPER8

---

LAN8720驱动

可参考LAN8720的资料，主要看寄存器和其配置。所以PHY前16个寄存器是一致的，符合IEEE的标准，能够驱动10/100Mb的网络通信，所以NXP的PHY芯片驱动和LAN8720的驱动大致相同。

---

修改LAN8720需要一下步骤
* (1)修改网络地址

### 修改网络地址
如上一节介绍的一样，需要修改PHY外部芯片的地址。在`ixm6ull_alientek_emmmc.h`中
```
#ifdef CONFIG_CMD_NET /*使能网络相关的命令需要的宏定义 后续定义才有效*/
#define CONFIG_CMD_PING
#define CONFIG_CMD_DHCP
#define CONFIG_CMD_MII
#define CONFIG_FEC_MXC
#define CONFIG_MII
#define CONFIG_FEC_ENET_DEV		1 /*配置为ENET2 值为0为ENET1*/

#if (CONFIG_FEC_ENET_DEV == 0) /*ENET1配置*/
#define IMX_FEC_BASE			ENET_BASE_ADDR
#define CONFIG_FEC_MXC_PHYADDR          0x2 /*外部PHY芯片的地址*/
#define CONFIG_FEC_XCV_TYPE             RMII
#elif (CONFIG_FEC_ENET_DEV == 1) /*ENET2配置*/
#define IMX_FEC_BASE			ENET2_BASE_ADDR
#define CONFIG_FEC_MXC_PHYADDR		0x1
#define CONFIG_FEC_XCV_TYPE		RMII
#endif
#define CONFIG_ETHPRIME			"FEC"
```

### LAN8720驱动编写
首先在`imx67ull_alientek_emmc.c`中注释掉NXP官方相关的PHY驱动。分别是
```
#define IOX_SDI IMX_GPIO_NR(5, 10)
#define IOX_STCP IMX_GPIO_NR(5, 7)
#define IOX_SHCP IMX_GPIO_NR(5, 11)
#define IOX_OE IMX_GPIO_NR(5, 8)
```

`static iomux_v3_cfg_t const iox_pads[]` 、 `static void iox74lv_init(void)`  `void iox74lv_set(int index)`这三段代码块

最后，在board_init()中注释掉调用的`imx_iomux_v3_setup_multiple_pads(iox_pads, ARRAY_SIZE(iox_pads));`和`iox74lv_init`即可

接下来，就要添加自己的驱动。同LCD一样，首先是找到配置GPIO的文件进行修改。在`mu6ull_alientek_emmc.c`中找到
```
#ifdef CONFIG_FEC_MXC
/*
 * pin conflicts for fec1 and fec2, GPIO1_IO06 and GPIO1_IO07 can only
 * be used for ENET1 or ENET2, cannot be used for both.
 * 网络配置GPIO管脚 对照原理图一一修改
 */
static iomux_v3_cfg_t const fec1_pads[] = {
	MX6_PAD_GPIO1_IO06__ENET1_MDIO | MUX_PAD_CTRL(MDIO_PAD_CTRL),
	MX6_PAD_GPIO1_IO07__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
	MX6_PAD_ENET1_TX_DATA0__ENET1_TDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
	MX6_PAD_ENET1_TX_DATA1__ENET1_TDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
	MX6_PAD_ENET1_TX_EN__ENET1_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
	MX6_PAD_ENET1_TX_CLK__ENET1_REF_CLK1 | MUX_PAD_CTRL(ENET_CLK_PAD_CTRL),
	MX6_PAD_ENET1_RX_DATA0__ENET1_RDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
	MX6_PAD_ENET1_RX_DATA1__ENET1_RDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
	MX6_PAD_ENET1_RX_ER__ENET1_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),
	MX6_PAD_ENET1_RX_EN__ENET1_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
	MX6_PAD_SNVS_TAMPER7__GPIO5_IO07 | MUX_PAD_CTRL(NO_PAD_CTRL); /*正点原子复用IO5_IO07为PHY的复位管脚*/
};

static iomux_v3_cfg_t const fec2_pads[] = {
	MX6_PAD_GPIO1_IO06__ENET2_MDIO | MUX_PAD_CTRL(MDIO_PAD_CTRL),
	MX6_PAD_GPIO1_IO07__ENET2_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),

	MX6_PAD_ENET2_TX_DATA0__ENET2_TDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
	MX6_PAD_ENET2_TX_DATA1__ENET2_TDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
	MX6_PAD_ENET2_TX_CLK__ENET2_REF_CLK2 | MUX_PAD_CTRL(ENET_CLK_PAD_CTRL),
	MX6_PAD_ENET2_TX_EN__ENET2_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),

	MX6_PAD_ENET2_RX_DATA0__ENET2_RDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
	MX6_PAD_ENET2_RX_DATA1__ENET2_RDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
	MX6_PAD_ENET2_RX_EN__ENET2_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
	MX6_PAD_ENET2_RX_ER__ENET2_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),
	MX6_PAD_SNVS_TAMPER8__GPIO5_IO08 | MUX_PAD_CTRL(NO_PAD_CTRL); /*正点原子复用IO5_IO08为PHY的复位管脚*/
};
```
对照修改如上，起始发现正点原子的PHY管教很大一部分和官方开发板的兼容，只有复位管教要自行定义

```
static void setup_iomux_fec(int fec_id)
{
	if (fec_id == 0) /*ENET1*/
	{
		imx_iomux_v3_setup_multiple_pads(fec1_pads, ARRAY_SIZE(fec1_pads));
		
		gpio_direction_output(ENET1_RSET , 1);//输出模式
		gpio_set_value(ENET1_RSET , 0); //复位
		mdelay(20);
		gpio_set_value(ENET1_RSET , 1); //复位

	}
		
	
	else/*ENET2*/
	{
		imx_iomux_v3_setup_multiple_pads(fec2_pads, ARRAY_SIZE(fec2_pads));
		gpio_direction_output(ENET2_RSET , 1);//输出模式
		gpio_set_value(ENET2_RSET , 0); //复位
		mdelay(20);
		gpio_set_value(ENET2_RSET , 1); //复位

	}
		
}
```

LAN8720需要在初始化后复位一下，否则可能u-boot识别不了

接下来，就可以烧写代码，验证下u-boot是否能够识别出来LAN8720。成果后的效果如图，成功识别出FEC1

![89](.\pictures\89.png)

最后一步，LAN8720在U-BOOT下，我们需要一个通用的网络配置文件phy.c,找到如下的代码，修改。

```
int genphy_update_link(struct phy_device *phydev)
{
	unsigned int mii_reg;
#ifdef CONFIG_PHY_SNSC
	/*u-boot更新网络速度是需要先复位LAN8720，先等待LAN8720复位成功*/
	static int lan8720_flag = 0;
	int bmcr_reg = 0;
	if(lan8720_flag == 0){
		bmcr_reg = phy_read(phydev, MDIO_DEVAD_NONE, MII_BMCR);
		phy_write(phydev, MDIO_DEVAD_NONE, MII_BMCR, BMCR_RESET);
		while(phy_read(phydev, MDIO_DEVAD_NONE, MII_BMCR) & 0X8000){ /*等待lan8720软复位成功*/
			udelay(100);
		}
		phy_write(phydev, MDIO_DEVAD_NONE, MII_BMCR, bmcr_reg);
		lan8720_flag = 1;
	}
 .
 .
 .
}
#endif 
```
成功后如图
![90](.\pictures\90.png)

---
## U-BOOT启动LINUX
### EMMC启动
即从ROM中启动，如何在ROM存放LINUX？可以看第一节 WINDOWS下烧写系统，通mfg工具实现。这里不在演示。

首先查看emmc有无LINUX镜像、设备树。
`mmc dev 1` 和`fatls mmc 1:1`查看
![91](.\pictures\91.png)

确定有必要的文件后，通过`fatload mmc 1:1 80800000 zImage` `fatload mmc 1:1 83000000 imx6ull-14x14-emmc-7-1024x600-c.dtb` 将程序读入内存指定位置

最后通过`bootz 80800000 - 83000000` bootz来启动

### 网络启动
通过网络tftp下载指定文件到指定位置，在bootz启动即可

## mx6ull_alientek_emmc.h详解
重点分析文件里面的两个宏定义`CONFIG_BOOTARGS`和`CONFIG_BOOTCOMMAND`

### CONFIG_BOOTCOMMAND
u-boot第一次运行的时候，会执行默认的u-boot的命令，其存放在env_default.h文件中。其中，关于开发板默认的u-boot命令，是
```
#ifdef	CONFIG_BOOTCOMMAND
	"bootcmd="	CONFIG_BOOTCOMMAND		"\0"
```
这一行就存放在mx6ull_alientek_emmc.h,用来引导u-boot正确启动开发板

CONFIG_BOOTCOMMAND如下：
```
#define CONFIG_BOOTCOMMAND \
	   "run findfdt;" \
	   "mmc dev ${mmcdev};" \
	   "mmc dev ${mmcdev}; if mmc rescan; then " \
		   "if run loadbootscript; then " \
			   "run bootscript; " \
		   "else " \
			   "if run loadimage; then " \
				   "run mmcboot; " \
			   "else run netboot; " \
			   "fi; " \
		   "fi; " \
	   "else run netboot; fi"
#endif
```
* **run findfdt**

目的就是为了设置对应板子的设备树名称的环境变量
```
"findfdt="\
			"if test $fdt_file = undefined; then " \
				"if test $board_name = EVK && test $board_rev = 9X9; then " \
					"setenv fdt_file imx6ull-9x9-evk.dtb; fi; " \
				"if test $board_name = EVK && test $board_rev = 14X14; then " \
					"setenv fdt_file imx6ull-14x14-evk.dtb; fi; " \
				"if test $fdt_file = undefined; then " \
					"echo WARNING: Could not determine dtb to use; fi; " \
			"fi;\0" \
```
首先判断fdt_file这一环境变量是不是undefined,显然是的

而后检查环境变量board_name是不是evk，并且board_rev即板子封装尺寸，分别对应 evk 9x9 和evk 14x14 

对应不同的evk板子，将设置环境变量fdt_file设置成不同的文件命，而且可见 fdt_file应该是存放设备树的文件命

* **mmc dev ${mmcdev};**

切换设备

根据查找
```
"mmcdev="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \

而 #define CONFIG_SYS_MMC_ENV_DEV 1
```
所以综上，是切换到dev 1，即切换到emmc。


```
"if run loadbootscript; then " \
			   "run bootscript; " \

"loadbootscript=" \
		"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
展开这些变量，得
loadbootscript = fatload mmc 1:1 80800000 boot.scr
```
即从boot.scr加载到808000000,但fatls查看emmc dev 1如下
![92](.\pictures\92.png)
所以上面的语句不会运行，只能运行下面的啦

* **run loadimgage**
```
"else " \
			   "if run loadimage; then " \

"loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}\0" \
展开为：
loadimage = fatload mmc 1:1 80800000 zImage
```
显然在内存中存在80800000的zImage有就会运行下面的语句

* **run mmcboot**
最终目的是为例执行`bootz 80800000 - 8300000`这条指令
```
 "if run loadimage; then " \
				   "run mmcboot; " \
展开mmcboot
"mmcboot=echo Booting from mmc ...; " \
		"run mmcargs; " \
		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
			"if run loadfdt; then " \
				"bootz ${loadaddr} - ${fdt_addr}; " \
			"else " \
				"if test ${boot_fdt} = try; then " \
					"bootz; " \
				"else " \
					"echo WARN: Cannot load the DT; " \
				"fi; " \
			"fi; " \
		"else " \
			"bootz; " \
		"fi;\0" \
```
&emsp;&emsp;&emsp;(1)重点在其会去执行环境变量`mmcargs`的语句。

&emsp;&emsp;&emsp;(2)boot_fdt = try,所以会执行，目的是加载设备树到DDR的指定位置
```
"if run loadfdt; then " \
				"bootz ${loadaddr} - ${fdt_addr}; " \
展开loadfdt = 
"loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
loadfdt = fatload mmc 1:1 83000000 imx6ull-14x14-evk.dtb
```

&emsp;&emsp;&emsp;(3)执行bootz
```
"if run loadfdt; then " \
				"bootz ${loadaddr} - ${fdt_addr}; " \
bootz 80800000 - 83000000
```
就启动了linux

以上就是u-boot默认运行时，运行CONFIG_BOOTCOMMAND的情况。


### CONFIG_BOOTARGS
bootargs保存着 uboot传递给 Linux内核的参数，在上一小节提到bootcmd中有一行`run mmcargs`，则`"mmcargs=setenv bootargs console=${console},${baudrate} " \
		CONFIG_BOOTARGS_CMA_SIZE \
		"root=${mmcroot}\0" \`

```
"mmcargs=setenv bootargs console=${console},${baudrate} " 
展开 "console=ttymxc0\0" \
```
&emsp;&emsp;&emsp;这一行将配置bootargs，为console。而console = ttymxc0，在linux中， 串口0就是ttymxc0，可见u-boot是通过串口给传递linux参数，后面的${baudrate}不出意外就是115200

&emsp;&emsp;&emsp;宏定义CONFIG_BOOTARGS_CMA_SIZE 为空，不管

&emsp;&emsp;&emsp; 最后一行命令`"root=${mmcroot}\0"`展开就是`"root=/dev/mmcblk1p2  rootwait rw\0 "`

所以，最终mmcargs展开成：
```
mmcargs=setenv bootargs console= ttymxc0, 115200 root= /dev/mmcblk1p2 rootwait rw
```

### console
console用来设置 linux终端 (或者叫控制台 )，也就是通过什么设备来和 Linux进行交互，是
串口还是 LCD屏幕？如果是串口的话应该是串口几等等。一般设置串口作为 Linux终端，这样
我们就可以在电脑上通过 SecureCRT来和 linux交互了。这里设置 console为 ttymxc0，因为 linux启动以后 I.MX6ULL的串口 1在 linux下的设备文件就是 /dev/ttymxc0，在 Linux下，一切皆文件。

console=ttymxc0,115200 即设置ttymxc0（串口1）作为linux终端，波特率为115200

### root
`root= /dev/mmcblk1p2  rootwait rw`又是什么意思呢？root用来设置根文件系统的位置， root=/dev/mmcblk1p2用于指明根文件系统存放在mmc设备 block1的分区2中，即mmcblk1p2

root后面有“ rootwait rw rootwait表示通知linux mmc设备初始化完成以后再挂载，否则的话
mmc设备还没初始化完成就挂载根文件系统会出错的。 rw表示根文件系统是可以读写的，不加
rw的话可能无法在根文件系统中进行写操作，只能进行读操作。

指明了root过后，只要保存在bootargs内，便可以成功启动linux。如果出现启动失败，请查看
kernel line这一行是否成功加载了bootargs
![93](.\pictures\93.png)
如图没有，那么在u-boot下手动装载bootargs即可
![94](.\pictures\94.png)

## u-boot下DDR初始化
u-boot的DDR初始化仍在imxdownload下从u-boot.bin变成u-boot.imx的时候就初始化好了

那么接下来就是两个问题，**u-boot.imx头部信息从何而来及 u-boot.imx的DCD中初始化DDR代码怎么修改**

在make u-boot.bin的最后几行，会输出一行
```
mkdir -p board/freescale/mx6ullevk/
  ./tools/mkimage -n board/freescale/mx6ullevk/imximage-ddr512.cfg.cfgtmp -T imximage -e 0x87800000 -d u-boot.bin u-boot.imx
```
可以看出u-boot.bin变成u-boot.imx是通过board/freescale/mx6ullevk/imximage-ddr512.cfg.cfgtmp 得来的

查看对应文件夹发现，没有imximage-ddr512.cfg.cfgtmp，但有imximage.cfg，这里面就是保存对应的DCD数据和DDR化代码的。

**注意：默认NXP官方的代码是初始化512MB的数据，其他容量和校准需要在代码上进行修改**

```
*
 * Device Configuration Data (DCD)
 *
 * Each entry must have the format:
 * Addr-type           Address        Value
 *
 * where:
 *	Addr-type register length (1,2 or 4 bytes)
 *	Address	  absolute address of the register
 *	value	  value to be stored in the register
 */

/* Enable all clocks */
DATA 4 0x020c4068 0xffffffff
DATA 4 0x020c406c 0xffffffff
DATA 4 0x020c4070 0xffffffff
DATA 4 0x020c4074 0xffffffff
DATA 4 0x020c4078 0xffffffff
DATA 4 0x020c407c 0xffffffff
DATA 4 0x020c4080 0xffffffff

DATA 4 0x020E04B4 0x000C0000
DATA 4 0x020E04AC 0x00000000
DATA 4 0x020E027C 0x00000030
DATA 4 0x020E0250 0x00000030
DATA 4 0x020E024C 0x00000030
DATA 4 0x020E0490 0x00000030
DATA 4 0x020E0288 0x000C0030
DATA 4 0x020E0270 0x00000000
DATA 4 0x020E0260 0x00000030
DATA 4 0x020E0264 0x00000030
DATA 4 0x020E04A0 0x00000030
DATA 4 0x020E0494 0x00020000
DATA 4 0x020E0280 0x00000030
DATA 4 0x020E0284 0x00000030
DATA 4 0x020E04B0 0x00020000
DATA 4 0x020E0498 0x00000030
DATA 4 0x020E04A4 0x00000030
DATA 4 0x020E0244 0x00000030
DATA 4 0x020E0248 0x00000030
DATA 4 0x021B001C 0x00008000
DATA 4 0x021B0800 0xA1390003
DATA 4 0x021B080C 0x00000004
DATA 4 0x021B083C 0x41640158
DATA 4 0x021B0848 0x40403237
DATA 4 0x021B0850 0x40403C33
DATA 4 0x021B081C 0x33333333
DATA 4 0x021B0820 0x33333333
DATA 4 0x021B082C 0xf3333333
DATA 4 0x021B0830 0xf3333333
DATA 4 0x021B08C0 0x00944009
DATA 4 0x021B08b8 0x00000800
DATA 4 0x021B0004 0x0002002D
DATA 4 0x021B0008 0x1B333030
DATA 4 0x021B000C 0x676B52F3
DATA 4 0x021B0010 0xB66D0B63
DATA 4 0x021B0014 0x01FF00DB
DATA 4 0x021B0018 0x00201740
DATA 4 0x021B001C 0x00008000
DATA 4 0x021B002C 0x000026D2
DATA 4 0x021B0030 0x006B1023
DATA 4 0x021B0040 0x0000004F
DATA 4 0x021B0000 0x84180000
DATA 4 0x021B0890 0x00400000
DATA 4 0x021B001C 0x02008032
DATA 4 0x021B001C 0x00008033
DATA 4 0x021B001C 0x00048031
DATA 4 0x021B001C 0x15208030
DATA 4 0x021B001C 0x04008040
DATA 4 0x021B0020 0x00000800
DATA 4 0x021B0818 0x00000227
DATA 4 0x021B0004 0x0002552D
DATA 4 0x021B0404 0x00011006
DATA 4 0x021B001C 0x00000000

#endif
```

详细的参数，可以参看裸机试验中DDR3测试的实验中用到的.ins文件下，对比即可


## u-boot图像化配置界面
u-boot除了可以通过deconfig实现配置和配置eemc.h来配置u-boot以外，还可以通过图像化界面配置。u-boot的图形化界面配置主要是方面linux开发，也符合大多数应用场景下的逻辑，后续linux中会用到，因此要着重学习

### 图像化界面配置步骤
&emsp;&emsp;&emsp;(1)用终端打开进入u-boot的源文件目录下

&emsp;&emsp;&emsp;(2)通过make deconfig与预配置一下，生成.config文件

&emsp;&emsp;&emsp;(3)终端输入 `sudo apt-get install libncurses5-dev`来安装必要的图像化界面库

&emsp;&emsp;&emsp;(4)最后在终端输入`make menuconfig`来进入图像化配置界面

![95](.\pictures\95.png)

### 图像化界面配置介绍
&emsp;&emsp;&emsp;(1)按下对应的高亮首字母可以快速跳转到对应选项

&emsp;&emsp;&emsp;(2)enter进入子菜单，连按两下esc退出

&emsp;&emsp;&emsp;(3)方向键可用于选择

&emsp;&emsp;&emsp;(4)按？可以打开帮助信息

&emsp;&emsp;&emsp;(5) 当一个菜单左侧有`[]`表示可选择模块编译进入u-boot，此时按Y可以选择这个选项编译进入u-boot，对应`[]`会变成`[*]`，按下N在表示该模块不编译进入u-boot

**注意：当配置好u-boot后，生成的.config需要手动保存，否则当重新编译工程的时候会清除.config文件,所以务必做好保存工作**

&emsp;&emsp;&emsp;(6)使用主菜单下的save选项，可以保存.config文件保存到其他地方，后面清理工程后在使用load加载即可

## u-boot图形化界面配置原理
上一节介绍了一些基本操作，现在来看看到底怎么运行的图像化配置界面

在顶层的makefile中，在熟悉的
```
config: scripts_basic outputmakefile FORCE
	$(Q)$(MAKE) $(build)=scripts/kconfig $@

%config: scripts_basic outputmakefile FORCE
	$(Q)$(MAKE) $(build)=scripts/kconfig $@
```
会用到kconfig文件，即图像化界面的配置文件,接下来就去看看kconfig如何配置图像化界面

### kconfig文件介绍
```
mainmenu "U-Boot $UBOOTVERSION Configuration"

config UBOOTVERSION
	string
	option env="UBOOTVERSION"
```
就对应图形化的
![96](.\pictures\96.png)

**值得注意的是同makefile一致，Kconfig也可以调用子目录下的Kconfig** 。这为图像化界面的子菜单提供了基础

```
# Allow defaults in arch-specific code to override any given here
source "arch/Kconfig"

menu "General setup"

config LOCALVERSION
	string "Local version - append to U-Boot release"
	help
	  Append an extra string to the end of your U-Boot version.
	  This will show up on your boot log, for example.
	  The string you set here will be appended after the contents of
	  any files with a filename matching localversion* in your
	  object and source tree, in that order.  Your total string can
	  be a maximum of 64 characters.
	  .
	  .
	  .
```
显然，第一行就是引用了arch/Kconfig下的Konfig。

**menu / endmenu 就对应了菜单中的对应选项**

**config xxx对应了配置项，它们是没有子菜单的**

图下图，menu General setup对应 图中General setup菜单，而进入后的config LOCALVERSION等就是选项

![97](.\pictures\97.png)
![98](.\pictures\98.png)


接下来，着重看看config项运用
```
config LOCALVERSION
	string "Local version - append to U-Boot release"
	help
	  Append an extra string to the end of your U-Boot version.
	  This will show up on your boot log, for example.
	  The string you set here will be appended after the contents of
	  any files with a filename matching localversion* in your
	  object and source tree, in that order.  Your total string can
	  be a maximum of 64 characters.
```
* config xxx如果要编译进入u-boot，其在生成的.config文件中会成为 config_xxx=y或者config_xxx=其他东西

* `string`是变量类型，也就是“ CONFIG_ LOCALVERSION”的变量类型。可以为
bool、 tristate、 string、 hex和 int，一共 5种。最常用的是 bool、 tristate和 string这三种， bool类
型有两种值： y和 n，当为 y的时候表示使能这个配置项，当为 n的时候就禁止这个配置项。
tristate类型有三种值： y、 m和 n，其中 y和 n的涵义与 bool类型一样， m表示将这个配置项编
译为模块。 string为字符串类型，所以 LOCALVERSION是个字符串变量，用来存储本地字符
串，选中以后即可输入用户定义的本地版本号，如图

在Kconfig中还有两类关键词 ，`depened on`和`select`

* `select`关键字表示同步选择。通常出现在config xxx下面，表示当选中config xxx后同步就选中了select yyy。如下段代码演示
```
config ARM
	bool "ARM architecture"
	select CREATE_ARCH_SYMLINK
	select HAVE_PRIVATE_LIBGCC if !ARM64
	select HAVE_GENERIC_BOARD
	select SYS_GENERIC_BOARD
	select SUPPORT_OF_CONTROL
```
选中config ARM同时就默认选中了 config CREATE_ARCH_SYMLINK、config HAVE_GENERIC_BOARD....
在.config中可以验证

* `depends on xxx`表示config xxx被选中后，才能选中以depends on xxx为子选项的选项

```
config SYS_MALLOC_F_LEN
	hex "Size of malloc() pool before relocation"
	depends on SYS_MALLOC_F
	default 0x400
	help
	  Before relocation memory is very limited on many platforms. Still,
	  we can provide a small malloc() pool if needed. Driver model in
	  particular needs this to operate, so that it can allocate the
	  initial serial device and any others that are needed.
	  .
	  .
	  .
```
depends on SYS_MALLOC_F即表示只有SYS_MALLOC_F被选中时，才选中config SYS_MALLOC_F_LEN

Konfig中还有两种不常见的关键词`menuconfig`和`comment`

* `menuconfig`就是menu和config的结合体。即它即使配置项，又是子菜单，可以进入也可以选中配置
![99](.\pictures\99.png)

* `comment`就是注释，在菜单中可以显示

### 客制化菜单
在根目录下的konfig最后加入如下代码
```
# 自定义的菜单选项
menu "My test menu"

config MY_TESTMENU
	bool "this is test menu config"
	default y
	help
	  this is just a test menu 

endmenu 		#My test menu

```
**注意：endmenu后必须空一行，否则编译会报错**


## linux系统内核编译与体验 
进入u-boot学习的第二部分，linux系统内核移植之前，先熟悉一下linux内核编译的流程

### linux内核不同版本的关系
主要涉及3中版本，liunx官方内核、NXP官方修改内核、正点原子官方修改内核

* liunx官方内核

&emsp;&emsp;&emsp;官方内核。直接去官网下载即可

* NXP官方内核
&emsp;&emsp;&emsp;在官方内核4.1.15版本上，适配NXP官方的开发板、NXP会打包成BSP、SDK里，在NXP官网下载就行

* 正点原子官方内核
&emsp;&emsp;&emsp;在NXP官方的基础上修改以适配正点原子的开发板，这样开发难度更小，且效率更高

同u-boot的编译一样，准备文件，解压并创建一个shell脚本方便编译

* 首先找到正点原子官方的linux内核 linux-imx-4.1.15-2.1.0-g3dc0a4b-v2.7.tar.bz2 放入ubuntu下/home/constant_z/linux/IMX6ULL/linux/alientek_linux下

* 解压后，创建一个shell脚本，同u-boot的脚本大致相同
```
#!/bin/sh
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distclean
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- imx_v7_defconfig
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- all -j16
```

*编译 ，因为有make menuconfig所以会出现图像化配置界面， 先不管，继续编译

**接下来请注意：如果编译出现**
```
/usr/bin/ld: scripts/dtc/dtc-parser.tab.o:(.bss+0x50): multiple definition of `yylloc'; scripts/dtc/dtc-lexer.lex.o:(.bss+0x0): first defined here

collect2: error: ld returned 1 exit status

make[2]: *** [scripts/Makefile.host:100：scripts/dtc/dtc] 错误 1

make[1]: *** [scripts/Makefile.build:403：scripts/dtc] 错误 2

make[1]: *** 正在等待未完成的任务....

HOSTLD scripts/mod/modpost

make: *** [Makefile:558：scripts] 错误 2

make: *** 正在等待未完成的任务....

```
请参考这边文章进行修改                    
[linux内核编译失败](https://blog.csdn.net/qq_43778130/article/details/129353547)


编译完成后，会在/home/constant_z/linux/IMX6ULL/linux/alientek_linux/arch/arm/boot出出现zImage的linux内核系统镜像

设备树文件存放在 /home/constant_z/linux/IMX6ULL/linux/alientek_linux/arch/arm/boot/dts下，设备树名称是`imx6ull-14x14-emmc-7-1024x600-c.dtb`


接下来，用tftp来下载验证即可。成功下载如下图所示
![100](.\pictures\100.png)


## linux内核源码分析
先压缩linux内核源码文件，到windos平台下去分析，这样效率更高

### 源码目录结构
![101](.\pictures\101.png)
![102](.\pictures\102.png)
![103](.\pictures\103.png)
可见u-boot一部分借鉴了linux内核的目录结构


### 一些要注意的重点文件

* arch/arm/boot下存储linux编译完成zImage，会重点分析

* arch/arm/boot/dts 存放linux所以dtb设备树文件，重点分析

* alientek_linux\Documentation\devicetree文件就是设备树的文档，会重点分析

* .cmd文件只有在编译后才能生成

## 顶层makefile分析
同 u-boot分析一样，先利用vscode创建settings.json来屏蔽掉一些不需要的文件


### 第一部分：make xxx_deconfig
**先说结论 make xxx_deconfig就是为了生成.config**

前面部分和u-boot的顶层makefile基本一致，故不作解释。重点就是那4行
```
config: scripts_basic outputmakefile FORCE
	$(Q)$(MAKE) $(build)=scripts/kconfig $@

%config: scripts_basic outputmakefile FORCE
	$(Q)$(MAKE) $(build)=scripts/kconfig $@
```
上面的语句对应的就是编译的shell文件中的`make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- imx_v7_defconfig`.显然，我们要给Linux编译指定默认的defconfig文件

继续深入，参看第一个依赖项
```
scripts_basic:
	$(Q)$(MAKE) $(build)=scripts/basic
	$(Q)rm -f .tmp_quiet_recordmcount
```

这个就是编译 

接下来，第二个依赖项 outputmakefile
```
outputmakefile:
ifneq ($(KBUILD_SRC),)
	$(Q)ln -fsn $(srctree) source
	$(Q)$(CONFIG_SHELL) $(srctree)/scripts/mkmakefile \
	    $(srctree) $(objtree) $(VERSION) $(PATCHLEVEL)
endif
```
直接打印KBUILD_SRC发现是空的，符合顶层makefile在KBUILD_SRC上方的注释，**这个KBUILD_SRC变量非常关键，它关联了几个其他的变量的值**

outputmakefile主要用于自动生成一个Makefile在

最后FORCE表示强制生成，即每次make都会执行这个语句

依赖项都生成后，就到了defconfig最核心的部分语句
```
%config:	
	$(Q)$(MAKE) $(build)=scripts/kconfig $@
#翻译过来就是
%config:	
	@make -f ./scripts/Makefile.build obj=scripts/kconfig xxx_defconfig
```
重点就是调用makefile.build来编译生成defconfig

在scripts/Makefile.build中就会在前面调用 obj = scripts/kconfig,就会调用scripts/kconfig/Makefile，其中有一行就是
```
%_defconfig: $(obj)/conf
	$(Q)$< $(silent) --defconfig=arch/$(SRCARCH)/configs/$@ $(Kconfig)
展开就是
%_defconfig: scripts/kconfig/conf 
	@ scripts/kconfig/conf --defconfig=arch/arm/configs/%_defconfig Kconfig
```
%_defconfig依赖 scripts/kconfig/conf，所以会编译 scripts/kconfig/conf.c生成 conf这个软件。
此软件就会将 %_defconfig中的配置输出到 .config文件中，最终生成 Linux kernel根目录下
的 .config文件。

### vmlinks过程
在生成了.config文件后，就可以开始正式编译linux内核了

顶层makefile中默认的目标是 _all,而_all依赖的目标是`all`

all目标的依赖如下
```
all: vmlinux
展开vmlinux:
vmlinux: scripts/link-vmlinux.sh $(vmlinux-deps) FORCE
```
vmlinux依赖于`scripts/link-vmlinux.sh `和`$(vmlinux-deps) = vmlinux-deps := $(KBUILD_LDS) $(KBUILD_VMLINUX_INIT) $(KBUILD_VMLINUX_MAIN)`
```
$(vmlinux-deps)的依赖项展开如下：
KBUILD_LDS  := arch/$(SRCARCH)/kernel/vmlinux.lds
KBUILD_VMLINUX_INIT := $(head-y) $(init-y)
KBUILD_VMLINUX_MAIN := $(core-y) $(libs-y) $(drivers-y) $(net-y)

---再次展开其中的变量---
head-y = arch/arm/kernel/head.o

init-y = init/built-in.o

drivers-y = drivers/built-in.o sound/built-in.o firmware/built-in.o

net-y = net/built-in.o

libs-y = arch/arm/lib/lib.a lib/lib.a arch/arm/lib/built-in.o lib/built-in.o

core-y = usr/built-in.o arch/arm/vfp/built-in.o \ arch/arm/vdso/built-in.o arch/arm/kernel/built-in.o \ arch/arm/mm/built-in.o arch/arm/common/built-in.o \ arch/arm/probes/built-in.o arch/arm/net/built-in.o \ arch/arm/crypto/built-in.o arch/arm/firmware/built-in.o \ arch/arm/mach-imx/built-in.o kernel/built-in.o\ mm/built-in.o fs/built-in.o \ ipc/built-in.o security/built-in.o \ crypto/built-in.o block/built-in.o
```
可见xxx-y，就是最终是编译进入linux内核的.o文件

依赖已经分析完了，就可以链接生成vmlinux，接下来看条件命令部分
```
ifdef CONFIG_HEADERS_CHECK
	$(Q)$(MAKE) -f $(srctree)/Makefile headers_check
endif
ifdef CONFIG_SAMPLES
	$(Q)$(MAKE) $(build)=samples
endif
ifdef CONFIG_BUILD_DOCSRC
	$(Q)$(MAKE) $(build)=Documentation
endif
ifdef CONFIG_GDB_SCRIPTS
	$(Q)ln -fsn `cd $(srctree) && /bin/pwd`/scripts/gdb/vmlinux-gdb.py
endif
	+$(call if_changed,link-vmlinux)
```

最终，将会生成
```
cmd_link-vmlinux = /bin/bash scripts/link-vmlinux.sh arm-linux-gnueabihf-ld -EL -p --no-undefined -X --pic-veneer --build-id
```
作用就是链接上述的依赖项的文件，将其链接生成为vmlinks.

接下里就是将vmlinks转换成想要的zImage，即最终的linux内核镜像


### bulit-in.o编译过程

接下来的一部分就是bulit-in.o的生成阶段部分

首先出现如下语句
```
$(sort $(vmlinux-deps)): $(vmlinux-dirs) ;
```
打印出这个两个变量的值
```
vmlinux-deps = arch/arm/kernel/vmlinux.lds arch/arm/kernel/head.o init/built-in.o usr/built-in.o arch/arm/vfp/built-in.o arch/arm/vdso/built-in.o arch/arm/kernel/built-in.o arch/arm/mm/built-in.o arch/arm/common/built-in.o arch/arm/probes/built-in.o arch/arm/net/built-in.o arch/arm/crypto/built-in.o arch/arm/firmware/built-in.o arch/arm/mach-imx/built-in.o kernel/built-in.o mm/built-in.o fs/built-in.o ipc/built-in.o security/built-in.o crypto/built-in.o block/built-in.o arch/arm/lib/lib.a lib/lib.a arch/arm/lib/built-in.o lib/built-in.o drivers/built-in.o sound/built-in.o firmware/built-in.o net/built-in.o

vmlinux-dirs = init usr arch/arm/vfp arch/arm/vdso arch/arm/kernel arch/arm/mm arch/arm/common arch/arm/probes arch/arm/net arch/arm/crypto arch/arm/firmware arch/arm/mach-imx kernel mm fs ipc security crypto block drivers sound firmware net arch/arm/lib lib
```

```
vmlinux-deps := $(KBUILD_LDS) $(KBUILD_VMLINUX_INIT) $(KBUILD_VMLINUX_MAIN)
```
推测vmlinux-deps就是编译bulit-in.o的目标集合,而依赖就是vmlinux-dirs所指向的文件路径

```
$(vmlinux-dirs): prepare scripts
	$(Q)$(MAKE) $(build)=$@
展开就是u
@ make -f ./scripts/Makefile.build obj=$@
```
显然Makefile.build将会引导生成obj指向的目标集合，就是vmlinux-deps里面的xxx.bulit-in.o

以vmlinux-dirs的第一个目标 init为例。看看怎么生成bulit-in.o

```
@ make -f ./scripts/Makefile.build obj=init
```
调用默认的Makefile.build的默认目标__bulid
```
__build: $(if $(KBUILD_BUILTIN),$(builtin-target) $(lib-target) $(extra-y)) \
	 $(if $(KBUILD_MODULES),$(obj-m) $(modorder-target)) \
	 $(subdir-ym) $(always)
	@:
```
变量的值如下
```
KBUILD_BUILTIN = 1
builtin-target =
lib-target =
extra-y =
KBUILD_MODULES =
obj-m =
modorder-target = scripts/basic/modules.order
subdir-ym =
always = scripts/basic/fixdep
```
那么，上述的目标可以简化成
```
__build: $(builtin-target) $(lib-target) $(extra-y)) $(subdir-ym) $(always)
@:

```
说先分析builtin-target
```
builtin-target := $(obj)/built-in.o

$(builtin-target): $(obj-y) FORCE
	$(call if_changed,link_o_target)

最终就是
$(obj)/built-in.o: $(obj-y) FORCE
	$(call if_changed,link_o_target)
```
**builtin-target的作用就是打包依赖中的所有.o文件成一个bulit-in.o文件** 执行的代码如下
```
#
# Rule to compile a set of .o files into one .o file
#
ifdef builtin-target
quiet_cmd_link_o_target = LD      $@
# If the list of objects to link is empty, just create an empty built-in.o
cmd_link_o_target = $(if $(strip $(obj-y)),\
		      $(LD) $(ld_flags) -r -o $@ $(filter $(obj-y), $^) \
		      $(cmd_secanalysis),\
		      rm -f $@; $(AR) rcs$(KBUILD_ARFLAGS) $@)
```

### make zImage
前面提到生成了Vmlink，现在需要将它压缩成最后的zImage
使用make 或者 make all命令是自动将vmlinux压缩成zImgae的。实际上，其命令在arch/arm/makefile中有详细的介绍

```
BOOT_TARGETS	= zImage Image xipImage bootpImage uImage

$(BOOT_TARGETS): vmlinux
	$(Q)$(MAKE) $(build)=$(boot) MACHINE=$(MACHINE) $(boot)/$@
boot := arch/arm/boot
```
同理，会调用makebuild来引导生成zImage且生成在，boot := arch/arm/boot/zImage中，可见**Makefile.bliud是核心文件之一**

## linux内核启动流程简要介绍

### vmlinux.lds

要分析 Linux启动流程，同样需要先编译一下 Linux源码，因为有很多文件是需要编译才
会生成的。首先分析 Linux内核的连接脚本文件 arch/arm/kernel/vmlinux.lds，通过链接脚本可以
找到 Linux内核的第一行程序是从哪里执行的。 vmlinux.lds中有如下代码：
```
OUTPUT_ARCH(arm)
ENTRY(stext)
jiffies = jiffies_64;
SECTIONS{
	.
	.
	.
}
```
vmlinux.lds首先链接的了一个stext的函数入口地址，在/arch/arm/kernel/head.S中
```
/*
 * Kernel startup entry point.
 * ---------------------------
 *
 * This is normally called from the decompressor code.  The requirements
 * are: MMU = off, D-cache = off, I-cache = dont care, r0 = 0,
 * r1 = machine nr, r2 = atags or dtb pointer.
 *
 * This code is mostly position independent, so if you link the kernel at
 * 0xc0008000, you call this at __pa(0xc0008000).
 *
 * See linux/arch/arm/tools/mach-types for the complete list of machine
 * numbers for r1.
 *
 * We're trying to keep crap to a minimum; DO NOT add any machine specific
 * crap here - that's what the boot loader (or in extreme, well justified
 * circumstances, zImage) is for.
 */
	.arm

	__HEAD
ENTRY(stext)
```
可见，首先linux内核启动需要先解压缩zImage，解压后才能运行stext

要启动linux内核的要求同u-boot最后启动内核的操作是一致的,如注释写的一样
```
This is normally called from the decompressor code.  The requirements are: MMU = off, D-cache = off, I-cache = dont care, r0 = 0,
r1 = machine nr, r2 = atags or dtb pointer.
```
对比一下u-boot启动内核时做的操作
```
int do_bootm_linux(int flag, int argc, char * const argv[], bootm_headers_t *images)
{

	.
	.
	.
	void (*kernel_entry)(int zero, int arch, uint params);
	.
	.
	kernel_entry = (void (*)(int, int, uint))images->ep;
	.
	.
	.
}
```
函数 kernel_entry，看名字“内核 _进入”，说明此函数是进入 Linux内核的，也就是最终的大 boos！！此函数有三个参数 zero arch params，第一个参数 zero同样为 0；第
二个参数为机器 ID 第三个参数 ATAGS或者设备树 (DTB)首地址， ATAGS是传统的方法，用
于传递一些命令行信息啥的，如果使用设备树的话就要传递设备树 (DTB)

传递完成后，就要开始正式启动linux内核了

* 检查是否进入SVC模式
```
safe_svcmode_maskall r9
```

* 读取处理器ID，ID值保存在r9寄存器为首地址的参数中
```
mrc	p15, 0, r9, c0, c0		@ get processor id
	bl	__lookup_processor_type		@ r5=procinfo r9=cpuid
	movs	r10, r5				@ invalid processor (r5=0)?
 THUMB( it	eq )		@ force fixup-able long branch encoding
	beq	__error_p			@ yes, error 'p'
```

* 验证dtb或者atags是否有效
```
/*
	 * r1 = machine no, r2 = atags or dtb,
	 * r8 = phys_offset, r9 = cpuid, r10 = procinfo
	 */
	bl	__vet_atags
```
__vet_atags的代码会验证dtb是否有效

* 创建页列表
```
bl	__create_page_tables
```
函数特别复杂，是关于linux内存管理的，后续再补充

* 保存 __mmap_switched的入口地址
```
ldr	r13, =__mmap_switched		@ address to jump to after
						@ mmu has been enabled
	adr	lr, BSYM(1f)			@ return (PIC) address
	mov	r8, r4				@ set TTBR1 to swapper_pg_dir
	ldr	r12, [r10, #PROCINFO_INITFUNC]
	add	r12, r12, r10
	ret	r12
```

* 使能mmu
```
b	__enable_mmu
	...
	-> b	__turn_mmu_on
		...
		-> mov	r3, r13 # r13存放__mmap_switched
		-> ret	r3 跳转到__mmap_switched
			...
			-> b	start_kernel #启动内核
```

### 第二阶段：启动内核
start_kernel是一个c函数，它就是启动linux内核的函数。详细可见[start_kernel的执行](https://blog.csdn.net/jasonactions/article/details/111715545)，内容量可能又是一整个阶段的内容

在初始化结束后，将在最后调用`rest_init();`,将激活linux内核

`rest_init()`的简要调用关系如下
```
start_kernel
	...
	-> rest_init()
		...
		-> kernel_thread(kernel_init, NULL, CLONE_FS);
		...
		-> kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);
		...
		-> cpu_startup_entry(CPUHP_ONLINE); CPU主进程退化为空闲进程
```

kernel_thread(kernel_init, NULL, CLONE_FS)就是创建一个init进程，init的PID为1

init进程的 PID为 1。 init进程一开始是内核进程 (也就是运行在内核态 )，后面 init进程会在根文件系统中查找名为“ init”这个程序，这个 init”程序处于用户态，通过运行这个 init”程
序， init进程就会实现从内核态到用户态的转变。

调用函数 kernel_thread创建 kthreadd内核进程，此内核进程的 PID为 2。 kthreadd进程负责所有内核进程的调度和管理。

最后调用函数 cpu_startup_entry来进入 idle进程， cpu_startup_entry会调用
cpu_idle_loop cpu_idle_loop是个 while循环，也就是 idle进程代码。 idle进程的 PID为 0 idle进程叫做空闲进程，如果学过 FreeRTOS或者 UCOS的话应该听说过空闲任务。 idle空闲进程就和空闲任务一样，当 CPU没有事情做的时候就在 idle空闲进程里面“瞎逛游”，反正就是给CPU找点事做。当其他进程要工作的时候就会抢占 idle进程，从而夺取 CPU使用权。其实大家应该可以看到 idle进程并没有使用 kernel_thread或者 fork函数来创建，因为它是有主进程演变而来的。

启动Linux后可以查看各个进程的PID，利用`ps -A`查看
![104](.\pictures\104.png)

### kernel_init()
```
kernel_init()
	...
	->kernel_init_freeable()
		...
		-> 串口打印设置标准输入输出设备
		-> 尝试寻找init程序
		...
	-> 检查init所在位置
```
串口打印的程序如下
```
if (sys_open((const char __user *) "/dev/console", O_RDWR, 0) < 0)
		pr_err("Warning: unable to open an initial console.\n");

	(void) sys_dup(0);
	(void) sys_dup(0);
```
linux启动后，将去打开/dev/console，而console就是u-boot中bootargs传递而来的数据

接下里，会试图在跟文件目录下寻找是否有init程序
```
if (!ramdisk_execute_command)
		ramdisk_execute_command = "/init";
```

运行完kernel_init_freeable()后，将会寻找init程序，并将其并入用户态
```
if (ramdisk_execute_command) {
		ret = run_init_process(ramdisk_execute_command);
		if (!ret)
			return 0;
		pr_err("Failed to execute %s (error %d)\n",
		       ramdisk_execute_command, ret);
	}
```
在kernel_init_freeable()中 ramdisk_execute_command = "/init";，即**现在根目录下有没有init程序**
![105](.\pictures\105.png)
显然，没有这个init程序

```
if (execute_command) {
		ret = run_init_process(execute_command);
		if (!ret)
			return 0;
		panic("Requested init %s failed (error %d).",
		      execute_command, ret);
	}
```
execute_command的值可以有下面的程序获得

```
static int __init init_setup(char *str)
{
	unsigned int i;

	execute_command = str;
	/*
	 * In case LILO is going to boot us with default command line,
	 * it prepends "auto" before the whole cmdline which makes
	 * the shell think it should execute a script with such name.
	 * So we ignore all arguments entered _before_ init=... [MJ]
	 */
	for (i = 1; i < MAX_INIT_ARGS; i++)
		argv_init[i] = NULL;
	return 1;
}
__setup("init=", init_setup);
```
实际就是uboot传递给Linux内核的bootargs，可以指定init的值，通过__setup来传递给execute_command

显然，u-boot的args中也并未配置,最后init进程在下面寻找
```
if (!try_to_run_init_process("/sbin/init") ||
	    !try_to_run_init_process("/etc/init") ||
	    !try_to_run_init_process("/bin/init") ||
	    !try_to_run_init_process("/bin/sh"))
		return 0;

	panic("No working init found.  Try passing init= option to kernel. "
	      "See Linux Documentation/init.txt for guidance.");
```
以上代码会逐一运行文件下的是否有init文件，找到了init就返回，否则会提示没有找到

最后找到了init
![106](.\pictures\106.png)

最后init找到，就会加载跟文件系统

## linux内核移植
在NXP官方的基础上修改linux内核适配正点原子开发板

将编译好的`zImage`和`imx6ull-14x14-evk-emmc.dtb`启动出现如图情况
![107](.\pictures\107.png)
这是因为找不到根文件系统导致的，所以是没问题的，只是NXP官方的开发板对应的zImage和dtb是兼容正点原子的！接下来只需要修改适配即可

同u-boot一样，修改xxx_defconfig和dtb即可

### 修改defconfig
在imx_v7_mfg_defconfig基础上创建imx_alientek_emmc_defconfig，在这个文件上做修改


###  修改dtb文件
设备树文件由arch/arm/boot/dts里面的`imx6ull-14x14-evk-emmc.dts`来生成，但我们选中`imx6ull-14x14-evk.dts`因为`imx6ull-14x14-evk-emmc.dts`是引用了`imx6ull-14x14-evk.dts`后做了一小部分修改而来，因此，为代码方便，直接`imx6ull-14x14-evk.dts`在修改即可

**这里，我将imx6ull-14x14-evk-emmc.dts中额外的代码直接复制到了`imx6ull-alientek-emmc.dts`中，发现可以运行，后续出错记得排查一下这个地方**

接下来修改arch/arm/boot/dts的Makefile文件，添加
```
imx6ull-14x14-ddr3-arm2-wm8958.dtb \
	imx6ull-14x14-evk.dtb \
	imx6ull-alientek-emmc.dtb \ ->添加这个
	imx6ull-14x14-evk-btwifi.dtb \
	imx6ull-14x14-evk-emmc.dtb \
```
使得dtb文件能顺利编译


## CPU主频及网络驱动修改
修改这里驱动的前提是板子能正常启动，及卡到没有跟文件系统那一块，也可以直接烧写了一个跟文件系统到emmc，在设置bootcmd和bootargs即可

## 根文件系统构建

### 什么是根文件系统
根文件系统一般也叫做rootfs,Linux中的根文件系统更像是一个文件夹或者叫做目录,在这个目录里面会有很多的子目录。根目录下和子目录中会有很多的文件，这些文件是 Linux运行所必须的，比如库、常用的软件和命令、设备文件、配置文件等等。

根文件系统首先是内核启动时所mount(挂载)的第一个文件系统，内核代码映像文件保存在根文件系统中，而系统引导启动程序会在根文件系统挂载之后从中把一些基本的初始化脚本和
服务等加载到内存中去运行。

linux的内核非常小，但其文件系统可以非常大，linux仅启动内核是没有任何意义的，需要利用挂载linux根文件系统，来实现多种多样的需求。比如linux命令，ls，就是一个文件（linux万物皆文件），它要顺利运行就需要挂载正确的根文件系统后，在文件系统中有ls这个文件

在根文件目录下能找到ls文件
![108](.\pictures\108.png)

### 根文件系统组成
已ubantu的linux根文件为例，详细看看根文件的组成
![109](.\pictures\109.png)

* **1 bin**
文件， bin文件就是可执行文件。所以此目录下存放着系统
需要的可执行文件，一般都是一些命令，比如 ls、 mv等命令。此目录下的命令系统的所有的客户都可以使用。

* **2 dev**
dev是 device的缩写，所以此目录下的文 件都是和设备有关的，此目录下的文件都是设备
文件。在 Linux下一切皆文件，即使是硬件设备，也是以文件的形式存在的，比如
/dev/ttymxc0(I.MX6ULL根目录会有此文件 )就表示 I.MX6ULL的串口 0，我们要想通过串口 0发送或者接收数据就要操作文件 /dev/ttymxc0，通过对文件 /dev/ttymxc0的读写操作来实现串口
0的数据收发。

* **3 etc**
此目录下存放着各种配置文件，有一些是ubuntu独有的，有些是linux通用的

* **4 lib**
lib是 library的简称，也就是库的意思，因此此目录下存放着 Linux所必须的库文件。这些
库文件是共享库，命令和用户编写的应用程序要使用这些库文件。

* ** 5 mnt**
临时挂载目录，一般是空目录，可以在此目录下创建空的子目录，比如 /mnt/sd、 /mnt/usb
这样就可以将 SD卡或者 U盘挂载到 /mnt/sd或者 /mnt/usb目录中。

* **6 proc**
此目录一般是空的，当 Linux系统启动以后 会将此目录作为 proc文件系统的挂载点， proc是个虚拟文件系统，没有实际的存储设备。 proc里面的文件都是临时存在的，一般用来存储系
统运行信息文件。

* **7 usr**
要注意， usr不是 user的缩写，而是 Unix Software Resource的缩写，也就是 Unix操作系统
软件资源目录。这里有个小知识点，那就是 Linux一般被 称为类 Unix操作系统，苹果的 MacOS也是类 Unix操作系统。关于 Linux和 Unix操作系统的渊源大家可以直接在网上找 Linux的发展历史来看。既然是软件资源目录，因此 /usr目录下也存放着很多软件，一般系统安装完成以
后此目录占用的空间最多。

* **8 var**
此目录存放一些可以改变的数据。

* **9 sbin**
此目录页用户存放一些可执行文件，但是此目录下的文件或者说命令只有管理员才能使用，主要用户系统管理。一般嵌入式Linux用不到

* **10 sys**
系统启动以后此目录作为 sysfs文件系统的挂载点， sysfs是一个类似于 proc文件系统的特殊文件系统， sysfs也是基于 ram的文件系统，也就是说它也没有实际的存储设备。此目录是系统设备管理的重要目录，此目录通过一定的组织结构向用户提供详细的内核数据结构信息。

以上便是linux系统根文件的大致组成，没有提到的图中文件就是ubuntu独有的，不做介绍

## BusyBos构建根文件系统
BusyBox是一个集成了大量的 Linux命令和工具的软件，像 ls、 mv、 ifconfig等命令 BusyBox都会提供。 BusyBox就是一个大的工具箱，这个工具箱里面集成了 Linux的许多工具和命令。一般下载 BusyBox的源码，然后配置 BusyBox，选择自己想要的功能，最后编译即可。

总的而言,BusyBox是创建基本根文件的很好的工具，它能让我们专注于自己特定的根文件创建而不管基本的根文件。

### Busybox编译
将Busybox源码将编译后放到ubuntu下，开发板启动以后通过nfs服务将根文件下载到开发板上

首先将Busybox源码解压到Imx6u/tool/下，并在nfs指定文件夹下创建一个rootfs,存放一会要挂载的根文件系统

* **修改ARCH 和 CROSS_COMPILE**

**注意：请直接指定ARCH CROSS_COMPILE的值，因为修改之前有相关ARCH CROSS_COMPILE 使用的是 ?= ,所以后续修改不生效，直接注释掉原来代码再修改**

* **Busybox支持中文字符支持**
修改Busybox的一些配置，使其编译后的根文件能在控制台显示输入和输出中文字符

找到printable_string.c文中的printable_string，修改陈如下形式
```
const char* FAST_FUNC printable_string(uni_stat_t *stats, const char *str)
{
	char *dst;
	const char *s;

	s = str;
	while (1) {
		unsigned char c = *s;
		if (c == '\0') {
			/* 99+% of inputs do not need conversion */
			if (stats) {
				stats->byte_count = (s - str);
				stats->unicode_count = (s - str);
				stats->unicode_width = (s - str);
			}
			return str;
		}
		if (c < ' ')
			break;
		// if (c >= 0x7f)
		// 	break;
		s++;
	}

#if ENABLE_UNICODE_SUPPORT
	dst = unicode_conv_to_printable(stats, str);
#else
	{
		char *d = dst = xstrdup(str);
		while (1) {
			unsigned char c = *d;
			if (c == '\0')
				break;
			// if (c < ' ' || c >= 0x7f)
			// 	*d = '?';
			if(c < ' ')
				*d = '?';
			d++;
		}
		if (stats) {
			stats->byte_count = (d - dst);
			stats->unicode_count = (d - dst);
			stats->unicode_width = (d - dst);
		}
	}
#endif
	return auto_string(dst);
}
```

接下来，找到unicode.c修改成如下形式
```
static char* FAST_FUNC unicode_conv_to_printable2(uni_stat_t *stats, const char *src, unsigned width, int flags)
{
	char *dst;
	unsigned dst_len;
	unsigned uni_count;
	unsigned uni_width;

	if (unicode_status != UNICODE_ON) {
		char *d;
		if (flags & UNI_FLAG_PAD) {
			d = dst = xmalloc(width + 1);
			while ((int)--width >= 0) {
				unsigned char c = *src;
				if (c == '\0') {
					do
						*d++ = ' ';
					while ((int)--width >= 0);
					break;
				}
				// *d++ = (c >= ' ' && c < 0x7f) ? c : '?';
				*d++ = (c >= ' ') ? c : '?';
				src++;
			}
			*d = '\0';
		} else {
			d = dst = xstrndup(src, width);
			while (*d) {
				unsigned char c = *d;
				// if (c < ' ' || c >= 0x7f)
				// 	*d = '?';
				if(c < ' ')
					*d = '?';
				d++;
			}
		}
		.
		.
		.
	}
}
```
这样就支持中文字符了

* 修改成功后在对应文件下，就有一些根文件系统了
![110](.\pictures\110.png)
可以看出， rootfs目录下有 bin、 sbin和 usr这三个目录，以及 linuxrc这个文件。前面说过 Linux内核 init进程最后会查找用户空间的 init程序，找到以后就会运行这个用户空间的 init程序，从而切换到用户态。如果 bootargs设置 init=/linuxrc，那么 linuxrc就是可以作为用户空间的 init程序，所以用户态空间的 init程序是 busybox来生成的。
![111](.\pictures\111.png)
可见，最基础的根文件系统已经移植好了但它仍然是不全面的，它需要动态库

### 添加动态库
Linux中的应用程序一般都是需要动态库的，当然你也可以编译成静态的，但是静态的可
执行文件会很大。如果编译为动态的话就需要动态库，所以我们需要向根文件下添加动态库。为了后续方便，直接一次性创建基础根目录所需的所有文件夹或者文件，如图所示
![112](.\pictures\112.png)

接下来，我们在lib下存放我们需要的动态库

在ubuntu下，输入以下命令
```
cd /usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/lib

cp *so* *.a /home/constant_z/linux/nfs/rootfs/lib/ -d

进入 rootfs下，删除ld-linux-armhf.so.3,后再在usr/loc...下复制 ld-linux-armhf.so.3到rootfs

cd /usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/lib

cp *so* *.a /home/constant_z/linux/nfs/rootfs/lib/ -d
```
完成rootfs/lib部分要的库文件，接下来，在usr/lib下移植需要的库文件

```
cd /usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/ usr/lib

cp *so* *.a /home/zuozhongkai/linux/nfs/rootfs/usr/lib/ -d
```
这样，需要的库就全部移植好了，接下就是配置bootargs来自动开机挂载根文件了

### 初步测试
为例方便测试，挂载nfs来进行测试根文件系统，及根文件系统还在主机下，开发板启动后通过nfs来过载根文件即可，而不需要实际下载到emmc中，节省时间

* 配置liunx内核网络驱动工作

确保 nfs功能能正常即可，不行的看之前u-boot网络配置章节的相关介绍

* 修改uboot的bootargs
进入u-boot输入下面的命令
```
setenv bootargs 'console=ttymxc0,115200 root=/dev/nfs nfsroot=192.168.1.106:/home/constant_z/linux/nfs/rootfs,proto=tcp rw ip=192.168.1.106:192.168.1.250:192.168.1.1: 255.255.255.0::eth0:off'
```
以上命令及其说明在linux内核源码的文档中有详细说明 Documentation/filesystems/nfs/ nfsroot.txt，格式
```
root=/dev/nfs nfsroot=[<server-ip>:]<root-dir>[,<nfs-options>] ip=<client-ip>:<server-ip>:<gw-ip>:<netmask>:<hostname>:<device>:<autoconf>:<dns0-ip>:<dns1-ip>
```
![111](.\pictures\111.png)

## 完善根文件系统
由上诉图片可知`can't run /etc/init.d/rcS`,那么就在对应位置创建一个这样的文件，写如下代码
**注意：etc是root用户文件夹，在ubuntu上写的时候要切换到roo用户**
```
!/bin/sh

PATH=/sbin:/bin:/usr/sbin:/usr/bin:$PATH
LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/lib:/usr/lib
export PATH LD_LIBRARY_PATH

mount -a
mkdir /dev/pts
mount -t devpts devpts /dev/pts

echo /sbin/mdev > /proc/sys/kernel/hotplug
mdev -s

```
之后，修改rcS权限。



## 完整系统测试

### 运行一个arm应用程序

### 中文测试

### 开机自启动


## EMMC烧写
在测试成功过后，我们就可以将移植好的zImage ,设备树、和根文件系统烧写到开发吧的EMMC中，直接通过EMMC启动即可

### Mfgtool工具简介
Mfgtool是NXP官方提供的烧写emmc工具，先认识以下mfgtool，为之后改造其烧写自己的系统做准备

主要分两部分`向DDR中下载LINUX系统`和`利用DDR中的linux系统完成EMMC的烧写工作`

在文件中的.\Profile\Liunx\OS Fimware\下有两个文件夹，`files`和`firmware`，启动`files`保存最终烧写到开发板中的u-boot.imx和zImage dtb和rootfs。而`firmware`仅有u-boot.imx、zImage、dtb。

显然，第一步是下载firmware到ddr中，在通过Linux写入files到emmc中

主目录下的.vbs就是来实现上述目标的烧写脚本，找到对应的文件烧写到对应的地方，对应imx6ull的.vbs是`mfgtool2-yocto-mx-evk-emmc.vbs`

查看`mfgtool2-yocto-mx-evk-emmc.vbs`代码如下
```
Set wshShell = CreateObject("WScript.shell")
wshShell.run "mfgtool2.exe -c ""linux"" -l ""eMMC"" -s ""board=sabresd"" -s ""mmc=1"" -s ""6uluboot=14x14evk"" -s ""6uldtb=14x14-evk"""
Set wshShell = Nothing
```
以上是window的脚本
第一行是windos脚本运行的必要步骤，创建一个"wshShell对象

下一行首先是首先打开mfgtool2.exe，并向其传递后面那一堆参数，，以便正确烧写对应的东西

在`\mfgtools\Profiles\Linux\OS Firmware`下的ucl2.文件

```
<UCL>
  <CFG>
    <STATE name="BootStrap" dev="MX6SL" vid="15A2" pid="0063"/>
    <STATE name="BootStrap" dev="MX6D" vid="15A2" pid="0061"/>
    <STATE name="BootStrap" dev="MX6Q" vid="15A2" pid="0054"/>
    <STATE name="BootStrap" dev="MX6SX" vid="15A2" pid="0071"/>
    <STATE name="BootStrap" dev="MX6UL" vid="15A2" pid="007D"/>
    <STATE name="BootStrap" dev="MX7D" vid="15A2" pid="0076"/>
    <STATE name="BootStrap" dev="MX6ULL" vid="15A2" pid="0080"/>
    <STATE name="Updater"   dev="MSC" vid="066F" pid="37FF"/>
  </CFG>

```
这一段是先通过PID来判断对应的CPU型号，可以推测这些值应该是通过下载工具传递进去的，用于后续选择对应的CPU和开发板及其下载模式的选择

```
 <LIST name="eMMC" desc="Choose eMMC as media">
	<CMD state="BootStrap" type="boot" body="BootStrap" file ="firmware/u-boot-imx6q%plus%%board%_sd.imx" ifdev="MX6Q">Loading U-boot</CMD>
	<CMD state="BootStrap" type="boot" body="BootStrap" file ="firmware/u-boot-imx6dl%board%_sd.imx" ifdev="MX6D">Loading U-boot</CMD>
	<CMD state="BootStrap" type="boot" body="BootStrap" file ="firmware/u-boot-imx6sx%board%_emmc.imx" ifdev="MX6SX">Loading U-boot</CMD>
	<CMD state="BootStrap" type="boot" body="BootStrap" file ="firmware/u-boot-imx7d%7duboot%_sd.imx" ifdev="MX7D">Loading U-boot</CMD>
	<CMD state="BootStrap" type="boot" body="BootStrap" file ="firmware/u-boot-imx6ul%6uluboot%_emmc.imx" ifdev="MX6UL">Loading U-boot</CMD>
	<CMD state="BootStrap" type="boot" body="BootStrap" file ="firmware/u-boot-imx6ul%lite%%6uluboot%_emmc.imx" ifdev="MX6ULL">Loading U-boot</CMD>	
```
以这u按为例，就是选择了EMMC下载，就通过对应的'dev'来选择对应的u-boot。

选中SD卡下载方式后，IMX6ULL的u-boot下载在
```
<LIST name="SDCard" desc="Choose SD Card as media">

	<CMD state="BootStrap" type="boot" body="BootStrap" file ="firmware/u-boot-imx6ul%lite%6uluboot_sd.imx" ifdev="MX6ULL">Loading U-boot</CMD>

	<CMD state="BootStrap" type="load" file="firmware/zImage" address="0x80800000"
		loadSection="OTH" setSection="OTH" HasFlashHeader="FALSE" ifdev="MX6SL MX6SX MX7D MX6UL MX6ULL">Loading Kernel.</CMD>
	
	<CMD state="BootStrap" type="load" file="firmware/zImage-imx6ul%lite%-%6ulldtb%%ldo%.dtb" address="0x83000000"
		loadSection="OTH" setSection="OTH" HasFlashHeader="FALSE" ifdev="MX6ULL">Loading device tree.</CMD>
	
	<CMD state="Updater" type="push" body="pipe tar -jxv -C /mnt/mmcblk%mmc%p2" file="files/rootfs_nogpu.tar.bz2" ifdev="MX6UL MX7D MX6ULL">Sending and writting rootfs</CMD>

</LIST>
```
`%lite = 'l'`  , `%6uluboot_sd = 14x14`,所以下载的是`u-boot-imx6ull_14x14_evk_sd.imx`,其他的同理，关键在于打开对应的文件夹，比较文件名字的差异来推测引用的是什么

### 改造Mfgtool
简单来说，就是修改ucl2.xml文件，修改自己开发版的zImage、dtb和根文件系统的文件命符合xml的文件命即可。

xml文件下载分为两部，是加载和下载，加载的文件夹是`firmware`而下载的文件夹是`file`，意味着两边都要修改

两个文件夹下，u-boot dtb和 zImage都是一样的名字，只有根文件不一样

xml文件下指定的u-boot的文件名是`u-boot-imx6ull14x14evk_emmc.imx`

zImage对应的文件命是`zImage`

dtb文件时`zImage-imx6ull-14x14-evk-emmc.dtb`

根文件仅在`file`下有，是`rootfs_nogpu.tar.bz2`

**将设配自己开发板的文件修改成上面的文件命即可，不要修改xml里面的文件命为自己的文件命，不然下不进去**

准备好后，即可使用mfgtool进行下载即可

下载成功界面即进入linux界面

接下俩，对mfgtool进行裁剪，以更好的单独适配正点原子开发板的下载，主要是两个方面`确定自己的系统文件`和`改造ucl2.xml`

针对file文件夹，只需留下`fsl-image-mfgtool-initramfs-imx6qdlsolo.cpio.gz.u-boot`其他均可删除，对`firmware`文件夹，则留下图中高亮的即可
![113](.\pictures\113.png)

接下来就是改写ucl2.xml，在改写之间，确定需要的四个文件的文件命如下所示

![114](.\pictures\114.png)

接下来，如下改写`ucl2.xmd`
```
<!--
* Copyright (C) 2012, Freescale Semiconductor, Inc. All Rights Reserved.
* The CFG element contains a list of recognized usb devices.
*  DEV elements provide a name, class, vid and pid for each device.
*
* Each LIST element contains a list of update instructions.
*  "Install" - Erase media and install firmware.
*  "Update" - Update firmware only.
*
* Each CMD element contains one update instruction of attribute type.
*  "pull" - Does UtpRead(body, file) transaction.
*  "push" - Does UtpWrite(body, file) transaction.
*  "drop" - Does UtpCommand(body) then waits for device to disconnect.
*  "boot" - Finds configured device, forces it to "body" device and downloads "file".
*  "find" - Waits for "timeout" seconds for the "body" device to connect.
*  "show" - Parse and show device info in "file".  
-->


<UCL>
  <CFG>
    <STATE name="BootStrap" dev="MX6SL" vid="15A2" pid="0063"/>
    <STATE name="BootStrap" dev="MX6D" vid="15A2" pid="0061"/>
    <STATE name="BootStrap" dev="MX6Q" vid="15A2" pid="0054"/>
    <STATE name="BootStrap" dev="MX6SX" vid="15A2" pid="0071"/>
    <STATE name="BootStrap" dev="MX6UL" vid="15A2" pid="007D"/>
    <STATE name="BootStrap" dev="MX7D" vid="15A2" pid="0076"/>
    <STATE name="BootStrap" dev="MX6ULL" vid="15A2" pid="0080"/>
    <STATE name="Updater"   dev="MSC" vid="066F" pid="37FF"/>
  </CFG>

  <LIST name="eMMC" desc="Choose eMMC as media">
  
	<CMD state="BootStrap" type="boot" body="BootStrap" file ="firmware/u-boot-alientek-emmc.imx" ifdev="MX6ULL">Loading U-boot</CMD>	
	
	<CMD state="BootStrap" type="load" file="firmware/zImage-alientek-emmc" address="0x80800000"
		loadSection="OTH" setSection="OTH" HasFlashHeader="FALSE" ifdev="MX6SL MX6SX MX7D MX6UL MX6ULL">Loading Kernel.</CMD>

	<CMD state="BootStrap" type="load" file="firmware/%initramfs%" address="0x12C00000"
		loadSection="OTH" setSection="OTH" HasFlashHeader="FALSE" ifdev="MX6Q MX6D">Loading Initramfs.</CMD>
	<CMD state="BootStrap" type="load" file="firmware/%initramfs%" address="0x83800000"
		loadSection="OTH" setSection="OTH" HasFlashHeader="FALSE" ifdev="MX6SL MX6SX MX7D MX6UL MX6ULL">Loading Initramfs.</CMD>

	<CMD state="BootStrap" type="load" file="firmware/imx6ull-alientek-emmc.dtb" address="0x83000000"
		loadSection="OTH" setSection="OTH" HasFlashHeader="FALSE" ifdev="MX6ULL">Loading device tree.</CMD>

	<CMD state="BootStrap" type="jump" > Jumping to OS image. </CMD>


	<!-- create partition -->
	<CMD state="Updater" type="push" body="send" file="mksdcard.sh.tar">Sending partition shell</CMD>
	<CMD state="Updater" type="push" body="$ tar xf $FILE "> Partitioning...</CMD>
	<CMD state="Updater" type="push" body="$ sh mksdcard.sh /dev/mmcblk%mmc%"> Partitioning...</CMD>

	<!-- burn uboot -->
	<CMD state="Updater" type="push" body="$ dd if=/dev/zero of=/dev/mmcblk%mmc% bs=1k seek=768 conv=fsync count=8">clear u-boot arg</CMD>
	<!-- access boot partition -->
	<CMD state="Updater" type="push" body="$ echo 0 > /sys/block/mmcblk%mmc%boot0/force_ro">access boot partition 1</CMD>
	<CMD state="Updater" type="push" body="send" file="files/u-boot-alientek-emmc.imx" ifdev="MX6ULL">Sending u-boot.bin</CMD>
	<CMD state="Updater" type="push" body="$ dd if=$FILE of=/dev/mmcblk%mmc%boot0 bs=512 seek=2">write U-Boot to sd card</CMD>
	<CMD state="Updater" type="push" body="$ echo 1 > /sys/block/mmcblk%mmc%boot0/force_ro"> re-enable read-only access </CMD>
	<CMD state="Updater" type="push" body="$ mmc bootpart enable 1 1 /dev/mmcblk%mmc%">enable boot partion 1 to boot</CMD>

	<!-- create fat partition -->
	<CMD state="Updater" type="push" body="$ while [ ! -e /dev/mmcblk%mmc%p1 ]; do sleep 1; echo \"waiting...\"; done ">Waiting for the partition ready</CMD>
	<CMD state="Updater" type="push" body="$ mkfs.vfat /dev/mmcblk%mmc%p1">Formatting rootfs partition</CMD>
	<CMD state="Updater" type="push" body="$ mkdir -p /mnt/mmcblk%mmc%p1"/>
	<CMD state="Updater" type="push" body="$ mount -t vfat /dev/mmcblk%mmc%p1 /mnt/mmcblk%mmc%p1"/>

	<!-- burn zImage -->
	<CMD state="Updater" type="push" body="send" file="files/zImage-alientek-emmc">Sending kernel zImage</CMD>
	<CMD state="Updater" type="push" body="$ cp $FILE /mnt/mmcblk%mmc%p1/zImage">write kernel image to sd card</CMD>

	<!-- burn dtb -->
	<CMD state="Updater" type="push" body="send" file="files/imx6ull-alientek-emmc.dtb" ifdev="MX6ULL">Sending Device Tree file</CMD>

	<CMD state="Updater" type="push" body="$ cp $FILE /mnt/mmcblk%mmc%p1/imx6ull-alientek-emmc.dtb" ifdev="MX6ULL">write device tree to sd card</CMD>

	
	<CMD state="Updater" type="push" body="$ umount /mnt/mmcblk%mmc%p1">Unmounting vfat partition</CMD>

	<!-- burn rootfs -->
	<CMD state="Updater" type="push" body="$ mkfs.ext3 -F -E nodiscard /dev/mmcblk%mmc%p2">Formatting rootfs partition</CMD>
	<CMD state="Updater" type="push" body="$ mkdir -p /mnt/mmcblk%mmc%p2"/>
	<CMD state="Updater" type="push" body="$ mount -t ext3 /dev/mmcblk%mmc%p2 /mnt/mmcblk%mmc%p2"/>
	<CMD state="Updater" type="push" body="pipe tar -jxv -C /mnt/mmcblk%mmc%p2" file="files/rootfs-alientek-emmc.tar.bz2" ifdev="MX6UL MX7D MX6ULL">Sending and writting rootfs</CMD>
	<CMD state="Updater" type="push" body="frf">Finishing rootfs write</CMD>
	<CMD state="Updater" type="push" body="$ umount /mnt/mmcblk%mmc%p2">Unmounting rootfs partition</CMD>
	<CMD state="Updater" type="push" body="$ echo Update Complete!">Done</CMD>
  </LIST>

</UCL>
```

接下里，下载验证，开机即可。

至此，第三期 LINUX系统移植边告一段落，本期主要围绕了linux的三大件来介绍，u-boot、linux内核、根文件。u-boot负责引导进入linux内核，linux内核负责系统底层的资源管理，着重介绍了linux系统移植编译的zimage和设备树文件，这将在后面，linux驱动开发打基础，最后根文件的移植使得linux能真正的使用起来，并逐渐生根发芽

向第四期，前进！，最后以薇妹镇楼结束第三期的笔记


![薇妹](.\pictures\维尔利特.jpg)